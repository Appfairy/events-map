{"version":3,"sources":["webpack:///events_map.min.js","webpack:///webpack/bootstrap c16dc76038d000ef9cdf","webpack:///./src/custom_event.js","webpack:///./src/index.js","webpack:///./src/event_target.js","webpack:///./src/events_map.js","webpack:///./src/utils.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","CustomEvent","eventName","eventParams","arguments","length","undefined","TypeError","assign","bubbles","cancelable","detail","self","document","createEvent","initCustomEvent","create","window","Event","constructor","default","_interopRequireDefault","obj","_events_map","_custom_event","_event_target","EventTarget","this","_listeners","_pendingEvents","_custom_event2","_utils","SuperEventTarget","addEventListener","type","callback","options","e","push","removeEventListener","stack","splice","dispatchEvent","event","_this","defaultPrevented","silence","fn","_silenced","result","Function","queueEvent","onQueue","onDequeue","_this2","immediate","setImmediate","clearEvent","clearImmediate","_classCallCheck","instance","Constructor","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","EventsMap","context","_context","_bubbleEventsMap","Map","_captureEventsMap","eventTarget","eventHandler","useCapture","eventsMap","handlersMap","set","boundHandlersMap","boundEventHandler","bind","_len","args","Array","_key","off","apply","eventTargetExists","eventNameExists","eventHandlerExists","console","warn","delete","size","forEach","setTimeout","id","clearTimeout"],"mappings":"AAAAA,OAAOC,QACE,SAAUC,GCGnB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAH,OAGA,IAAAD,GAAAK,EAAAD,IACAE,EAAAF,EACAG,GAAA,EACAN,WAUA,OANAC,GAAAE,GAAAI,KAAAR,EAAAC,QAAAD,IAAAC,QAAAE,GAGAH,EAAAO,GAAA,EAGAP,EAAAC,QAvBA,GAAAI,KA+DA,OAnCAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAG,EAAA,SAAAK,GAA2C,MAAAA,IAG3CR,EAAAS,EAAA,SAAAX,EAAAY,EAAAC,GACAX,EAAAY,EAAAd,EAAAY,IACAG,OAAAC,eAAAhB,EAAAY,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAX,EAAAkB,EAAA,SAAArB,GACA,GAAAc,GAAAd,KAAAsB,WACA,WAA2B,MAAAtB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAG,GAAAS,EAAAE,EAAA,IAAAA,GACAA,GAIAX,EAAAY,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAlB,KAAAe,EAAAC,IAGtDrB,EAAAwB,EAAA,GAGAxB,IAAAyB,EAAA,KDOM,SAAU5B,EAAQC,EAASE,GAEjC,YEzEA,SAAS0B,GAAYC,GAA6B,GAAlBC,GAAkBC,UAAAC,OAAA,OAAAC,KAAAF,UAAA,GAAAA,UAAA,KAChD,KAAKF,EACH,KAAMK,WAAU,8BAGlB,IAAwB,gBAAbL,GACT,KAAMK,WAAU,8BAGlB,MAAMJ,YAAuBf,SAC3B,KAAMmB,WAAU,qCAGlBnB,QAAOoB,QACLC,SAAS,EACTC,YAAY,EACZC,WACCR,EAEH,IAAMS,GAAOC,SAASC,YAAY,cASlC,OAPAF,GAAKG,gBACHb,EACAC,EAAYM,QACZN,EAAYO,WACZP,EAAYQ,QAGPC,EFgDTxB,OAAOC,eAAehB,EAAS,cAC7BU,OAAO,IE9CTkB,EAAYJ,UAAYT,OAAO4B,OAAOC,OAAOC,MAAMrB,WACnDI,EAAYJ,UAAUsB,YAAclB,EF8EpC5B,EAAQ+C,QE5EOnB,GFgFT,SAAU7B,EAAQC,EAASE,GAEjC,YAkCA,SAAS8C,GAAuBC,GAAO,MAAOA,IAAOA,EAAI5B,WAAa4B,GAAQF,QAASE,GA/BvFlC,OAAOC,eAAehB,EAAS,cAC7BU,OAAO,GAGT,IAAIwC,GAAchD,EAAoB,EAEtCa,QAAOC,eAAehB,EAAS,WAC7BkB,YAAY,EACZC,IAAK,WACH,MAAO6B,GAAuBE,GGhIzBH,UHoIT,IAAII,GAAgBjD,EAAoB,EAExCa,QAAOC,eAAehB,EAAS,eAC7BkB,YAAY,EACZC,IAAK,WACH,MAAO6B,GAAuBG,GGxIzBJ,UH4IT,IAAIK,GAAgBlD,EAAoB,EAExCa,QAAOC,eAAehB,EAAS,eAC7BkB,YAAY,EACZC,IAAK,WACH,MAAO6B,GAAuBI,GGhJzBL,YHwJH,SAAUhD,EAAQC,EAASE,GAEjC,YIvJA,SAASmD,KACPC,KAAKC,cACLD,KAAKE,kBJwJPzC,OAAOC,eAAehB,EAAS,cAC7BU,OAAO,GIhKT,IAAAyC,GAAAjD,EAAA,GJqKIuD,EAIJ,SAAgCR,GAAO,MAAOA,IAAOA,EAAI5B,WAAa4B,GAAQF,QAASE,IAJ3CE,GIpK5CO,EAAAxD,EAAA,GAEMyD,EAAmBf,OAAOS,WAOhCA,GAAY7B,UAAYT,OAAO4B,OAAOgB,EAAiBnC,WACvD6B,EAAY7B,UAAUsB,YAAcO,EAEpCA,EAAY7B,UAAUoC,iBAAmB,SAAUC,EAAMC,EAAUC,GACjE,IAAKF,EACH,KAAM3B,WAAU,wBAGlB,IAAmB,gBAAR2B,GACT,KAAM3B,WAAU,wBAGlB,KAAK4B,EACH,KAAM5B,WAAU,4BAGlB,IAAuB,kBAAZ4B,GACT,KAAM5B,WAAU,8BAGlB,KACEyB,EAAiBnC,UAAUoC,iBAAiBrD,KAAK+C,KAAMO,EAAMC,EAAUC,GAEzE,MAAOC,IAIDH,IAAQP,MAAKC,aACjBD,KAAKC,WAAWM,OAGlBP,KAAKC,WAAWM,GAAMI,KAAKH,IAG7BT,EAAY7B,UAAU0C,oBAAsB,SAAUL,EAAMC,EAAUC,GACpE,IAAKF,EACH,KAAM3B,WAAU,wBAGlB,IAAmB,gBAAR2B,GACT,KAAM3B,WAAU,wBAGlB,KAAK4B,EACH,KAAM5B,WAAU,4BAGlB,IAAuB,kBAAZ4B,GACT,KAAM5B,WAAU,8BAGlB,KACEyB,EAAiBnC,UAAU0C,oBAAoB3D,KAAK+C,KAAMO,EAAMC,EAAUC,GAE5E,MAAOC,IAIP,GAAMH,IAAQP,MAAKC,WAMnB,IAAK,GAFCY,GAAQb,KAAKC,WAAWM,GAErBxD,EAAI,EAAGC,EAAI6D,EAAMnC,OAAQ3B,EAAIC,EAAGD,IACvC,GAAI8D,EAAM9D,KAAOyD,EAEf,WADAK,GAAMC,OAAO/D,EAAG,IAMtBgD,EAAY7B,UAAU6C,cAAgB,SAAUC,GAAO,GAAAC,GAAAjB,IACrD,KAAKgB,EACH,KAAMpC,WAAU,yBAGlB,MAAMoC,YAAiBzB,QACrB,KAAMX,WAAU,kCAGlB,MAAMoC,EAAMT,OAAQP,MAAKC,YACvB,OAAO,CAGT,IAAMY,GAAQb,KAAKC,WAAWe,EAAMT,KAEpC9C,QAAOC,eAAesD,EAAO,UAC3BrD,cAAc,EACdE,IAAK,iBAAAoD,KAGP,KAAK,GAAIlE,GAAI,EAAGC,EAAI6D,EAAMnC,OAAQ3B,EAAIC,EAAGD,IACvC8D,EAAM9D,GAAGE,KAAK+C,KAAMgB,EAGtB,QAAQA,EAAME,kBAGhBnB,EAAY7B,UAAUiD,QAAU,SAAUC,GACxC,IAAIpB,KAAKqB,UAAT,CAEArB,KAAKqB,WAAY,CACjB,IAAMN,GAAgBf,KAAKe,cACvBO,QAEJ,KACEtB,KAAKe,cAAgBQ,WACrBD,EAASF,EAAGnE,KAAK+C,MAFnB,QAKEA,KAAKqB,WAAY,EACjBrB,KAAKe,cAAgBA,EAGvB,MAAOO,KAGTvB,EAAY7B,UAAUsD,WAAa,SAAUjD,EAAWkD,EAASC,GAAW,GAAAC,GAAA3B,IAC1E,KAAIA,KAAKE,eAAe3B,KAAcyB,KAAKqB,UAA3C,CAEAI,EAAUA,GAAWF,WACrBG,EAAYA,GAAaH,UACzB,IAAMvC,KAENyC,GAAQzC,EAER,IAAM4C,IAAY,EAAAxB,EAAAyB,cAAa,iBACtBF,GAAKzB,eAAe3B,GAE3BmD,EAAU1C,GAEV2C,EAAKZ,cAAc,GAAAZ,GAAAV,QAAgBlB,GAAaS,aAGlDgB,MAAKE,eAAe3B,GAAaqD,IAGnC7B,EAAY7B,UAAU4D,WAAa,SAAUvD,GAC3C,GAAMqD,GAAY5B,KAAKE,eAAe3B,EAEjCqD,MAEL,EAAAxB,EAAA2B,gBAAeH,SAER5B,MAAKE,eAAe3B,KJ8K7B7B,EAAQ+C,QI3KOM,GJ+KT,SAAUtD,EAAQC,EAASE,GAEjC,YAeA,SAASoF,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAItD,WAAU,qCAZhHnB,OAAOC,eAAehB,EAAS,cAC7BU,OAAO,GAGT,IAAI+E,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIvF,GAAI,EAAGA,EAAIuF,EAAM5D,OAAQ3B,IAAK,CAAE,GAAIwF,GAAaD,EAAMvF,EAAIwF,GAAW3E,WAAa2E,EAAW3E,aAAc,EAAO2E,EAAW5E,cAAe,EAAU,SAAW4E,KAAYA,EAAWC,UAAW,GAAM/E,OAAOC,eAAe2E,EAAQE,EAAWE,IAAKF,IAAiB,MAAO,UAAUL,EAAaQ,EAAYC,GAAiJ,MAA9HD,IAAYN,EAAiBF,EAAYhE,UAAWwE,GAAiBC,GAAaP,EAAiBF,EAAaS,GAAqBT,MKtVhiBrC,EAAAjD,EAAA,GL0VIuD,EAEJ,SAAgCR,GAAO,MAAOA,IAAOA,EAAI5B,WAAa4B,GAAQF,QAASE,IAF3CE,GKxVtC+C,EL8VU,WK7Vd,QAAAA,KAA8B,GAAlBC,GAAkBpE,UAAAC,OAAA,OAAAC,KAAAF,UAAA,GAAAA,UAAA,GAARa,MAAQ0C,GAAAhC,KAAA4C,GAC5B5C,KAAK8C,SAAWD,EAChB7C,KAAK+C,iBAAmB,GAAIC,KAC5BhD,KAAKiD,kBAAoB,GAAID,KLsoB/B,MAjSAb,GAAaS,IACXH,IAAK,KACLrF,MAAO,SKpWN8F,EAAa3E,EAAW4E,EAAcC,GAQvC,GAP0B,gBAAfF,KACTE,EAAaD,EACbA,EAAe5E,EACfA,EAAY2E,EACZA,EAAclD,KAAK8C,WAGhBI,EACH,KAAMtE,WAAU,mCAGlB,MAAMsE,YAAuBnD,cAC3B,KAAMnB,WAAU,6CAGlB,KAAKL,EACH,KAAMK,WAAU,iCAGlB,IAAwB,gBAAbL,GACT,KAAMK,WAAU,uCAGlB,KAAKuE,EACH,KAAMvE,WAAU,oCAGlB,IAA2B,kBAAhBuE,GACT,KAAMvE,WAAU,wCAGlBwE,KAAeA,CACf,IAAMC,GAAYD,EAAapD,KAAKiD,kBAAoBjD,KAAK+C,iBACzDO,EAAcD,EAAUxF,IAAIqF,EAE3BI,KACHA,EAAc,GAAIN,KAClBK,EAAUE,IAAIL,EAAaI,GAG7B,IAAIE,GAAmBF,EAAYzF,IAAIU,EAElCiF,KACHA,EAAmB,GAAIR,KACvBM,EAAYC,IAAIhF,EAAWiF,GAG7B,IAAMC,GAAoBN,EAAaO,KAAK1D,KAAK8C,SAEjDU,GAAiBD,IAAIJ,EAAcM,GAEnCP,EAAY5C,iBAAiB/B,EAAWkF,EAAmBL,MLuW3DX,IAAK,OACLrF,MAAO,SKrWJ8F,EAAa3E,EAAW4E,EAAcC,GAAY,GAAAnC,GAAAjB,IAQrD,IAP0B,gBAAfkD,KACTE,EAAaD,EACbA,EAAe5E,EACfA,EAAY2E,EACZA,EAAclD,KAAK8C,WAGhBI,EACH,KAAMtE,WAAU,mCAGlB,MAAMsE,YAAuBnD,cAC3B,KAAMnB,WAAU,6CAGlB,KAAKL,EACH,KAAMK,WAAU,iCAGlB,IAAwB,gBAAbL,GACT,KAAMK,WAAU,uCAGlB,KAAKuE,EACH,KAAMvE,WAAU,oCAGlB,IAA2B,kBAAhBuE,GACT,KAAMvE,WAAU,wCAGlBwE,KAAeA,CACf,IAAMC,GAAYD,EAAapD,KAAKiD,kBAAoBjD,KAAK+C,iBACzDO,EAAcD,EAAUxF,IAAIqF,EAE3BI,KACHA,EAAc,GAAIN,KAClBK,EAAUE,IAAIL,EAAaI,GAG7B,IAAIE,GAAmBF,EAAYzF,IAAIU,EAElCiF,KACHA,EAAmB,GAAIR,KACvBM,EAAYC,IAAIhF,EAAWiF,GAG7B,IAAMC,GAAoB,WAAa,OAAAE,GAAAlF,UAAAC,OAATkF,EAASC,MAAAF,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAATF,EAASE,GAAArF,UAAAqF,EAGrC,OAFA7C,GAAK8C,IAAIb,EAAa3E,EAAW4E,EAAcC,GAExCD,EAAaa,MAAM/C,EAAK6B,SAAUc,GAG3CJ,GAAiBD,IAAIJ,EAAcM,GAEnCP,EAAY5C,iBAAiB/B,EAAWkF,EAAmBL,ML8W3DX,IAAK,MACLrF,MAAO,SK5WL8F,EAAa3E,EAAW4E,EAAcC,GACd,gBAAfF,KACTE,EAAaD,EACbA,EAAe5E,EACfA,EAAY2E,EACZA,EAAclD,KAAK8C,SAGrB,IAAImB,GAAoBf,YAAuBnD,aAC3CmE,EAAsC,gBAAb3F,GACzB4F,EAA4C,kBAAhBhB,EAEhC,IAAIc,GAAqBC,GAAmBC,EAAoB,CAC9Df,IAAe3E,UAAU,EAEzB,IAAM4E,GAAYD,EAAapD,KAAKiD,kBAAoBjD,KAAK+C,iBAEvDO,EAAcD,EAAUxF,IAAIqF,EAElC,KAAKI,EAEH,WADAc,SAAQC,KAAK,yBAIf,IAAMb,GAAmBF,EAAYzF,IAAIU,EAEzC,KAAKiF,EAEH,WADAY,SAAQC,KAAK,+BAIf,IAAMZ,GAAoBD,EAAiB3F,IAAIsF,EAE/C,KAAKM,EAEH,WADAW,SAAQC,KAAK,gCAIfb,GAAiBc,OAAOnB,GAEK,GAAzBK,EAAiBe,MACnBjB,EAAYgB,OAAO/F,GAGG,GAApB+E,EAAYiB,MACdlB,EAAUiB,OAAOpB,GAGnBA,EAAYtC,oBAAoBrC,EAAWkF,EAAmBL,OAE3D,IAAIa,GAAqBC,EAAiB,CAC7C,KAAMhB,YAAuBnD,cAC3B,KAAMnB,WAAU,6CAGlB,IAAwB,gBAAbL,GACT,KAAMK,WAAU,uCAGlBwE,KAAe3E,UAAU,EAEzB,IAAM4E,GAAYD,EAAapD,KAAKiD,kBAAoBjD,KAAK+C,iBAEvDO,EAAcD,EAAUxF,IAAIqF,EAElC,KAAKI,EAEH,WADAc,SAAQC,KAAK,yBAIf,IAAMb,GAAmBF,EAAYzF,IAAIU,EAEzC,KAAKiF,EAEH,WADAY,SAAQC,KAAK,+BAIff,GAAYgB,OAAO/F,GAEK,GAApB+E,EAAYiB,MACdlB,EAAUiB,OAAOpB,GAGnBM,EAAiBgB,QAAQ,SAACf,EAAmBN,GAC3CK,EAAiBc,OAAOnB,GAExBD,EAAYtC,oBAAoBrC,EAAWkF,EAAmBL,SAG7D,IAAIa,EAAmB,CAC1B,KAAMf,YAAuBnD,cAC3B,KAAMnB,WAAU,6CAGlBwE,KAAe3E,UAAU,EAEzB,IAAM4E,GAAYD,EAAapD,KAAKiD,kBAAoBjD,KAAK+C,iBAEvDO,EAAcD,EAAUxF,IAAIqF,EAElC,KAAKI,EAEH,WADAc,SAAQC,KAAK,yBAIfhB,GAAUiB,OAAOpB,GAEjBI,EAAYkB,QAAQ,SAAChB,EAAkBjF,GACrC+E,EAAYgB,OAAO/F,GAEnBiF,EAAiBgB,QAAQ,SAACf,EAAmBN,GAC3CK,EAAiBc,OAAOnB,GAExBD,EAAYtC,oBAAoBrC,EAAWkF,EAAmBL,WAI/D,CACHA,IAAe3E,UAAU,EAEzB,IAAM4E,GAAYD,EAAapD,KAAKiD,kBAAoBjD,KAAK+C,gBAE7DM,GAAUmB,QAAQ,SAAClB,EAAaJ,GAC9BG,EAAUiB,OAAOpB,GAEjBI,EAAYkB,QAAQ,SAAChB,EAAkBjF,GACrC+E,EAAYgB,OAAO/F,GAEnBiF,EAAiBgB,QAAQ,SAACf,EAAmBN,GAC3CK,EAAiBc,OAAOnB,GAExBD,EAAYtC,oBAAoBrC,EAAWkF,EAAmBL,aLgXtEX,IAAK,OACLrF,MAAO,SK1WJ8F,EAAa3E,EAAWC,GAO3B,GAN0B,gBAAf0E,KACT1E,EAAcD,EACdA,EAAY2E,EACZA,EAAclD,KAAK8C,WAGhBI,EACH,KAAMtE,WAAU,mCAGlB,MAAMsE,YAAuBnD,cAC3B,KAAMnB,WAAU,6CAGlB,KAAKL,EACH,KAAMK,WAAU,iCAGlB,IAAwB,gBAAbL,GACT,KAAMK,WAAU,uCAGlB,IAAMoC,GAAQ,GAAAb,GAAAV,QAAgBlB,EAAWC,EAEzC0E,GAAYnC,cAAcC,OL8WrB4B,IAGTlG,GAAQ+C,QK7WOmD,GLiXT,SAAUnG,EAAQC,EAASE,GAEjC,YMrpBO,SAASiF,GAAaT,GAC3B,OAAQ9B,OAAOuC,cAAgB4C,YAAYrD,GAGtC,QAASW,GAAe2C,GAC7B,OAAQpF,OAAOyC,gBAAkB4C,cAAcD,GNmpBjDjH,OAAOC,eAAehB,EAAS,cAC7BU,OAAO,IAETV,EM3pBgBmF,eN4pBhBnF,EMxpBgBqF,kBNmqBV,SAAUtF,EAAQC,EAASE,GAEjCH,EAAOC,QAAUE,EAAoB","file":"events_map.min.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction CustomEvent(eventName) {\n  var eventParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!eventName) {\n    throw TypeError('Event name must be provided');\n  }\n\n  if (typeof eventName != 'string') {\n    throw TypeError('Event name must be a string');\n  }\n\n  if (!(eventParams instanceof Object)) {\n    throw TypeError('Event parameters must be an object');\n  }\n\n  Object.assign({\n    bubbles: true,\n    cancelable: true,\n    detail: {}\n  }, eventParams);\n\n  var self = document.createEvent('CustomEvent');\n\n  self.initCustomEvent(eventName, eventParams.bubbles, eventParams.cancelable, eventParams.detail);\n\n  return self;\n}\n\nCustomEvent.prototype = Object.create(window.Event.prototype);\nCustomEvent.prototype.constructor = CustomEvent;\n\nexports.default = CustomEvent;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _events_map = __webpack_require__(3);\n\nObject.defineProperty(exports, 'default', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_events_map).default;\n  }\n});\n\nvar _custom_event = __webpack_require__(0);\n\nObject.defineProperty(exports, 'CustomEvent', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_custom_event).default;\n  }\n});\n\nvar _event_target = __webpack_require__(2);\n\nObject.defineProperty(exports, 'EventTarget', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_event_target).default;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _custom_event = __webpack_require__(0);\n\nvar _custom_event2 = _interopRequireDefault(_custom_event);\n\nvar _utils = __webpack_require__(4);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar SuperEventTarget = window.EventTarget;\n\nfunction EventTarget() {\n  this._listeners = {};\n  this._pendingEvents = {};\n}\n\nEventTarget.prototype = Object.create(SuperEventTarget.prototype);\nEventTarget.prototype.constructor = EventTarget;\n\nEventTarget.prototype.addEventListener = function (type, callback, options) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  try {\n    SuperEventTarget.prototype.addEventListener.call(this, type, callback, options);\n  } catch (e) {\n    // Not a native event target\n  }\n\n  if (!(type in this._listeners)) {\n    this._listeners[type] = [];\n  }\n\n  this._listeners[type].push(callback);\n};\n\nEventTarget.prototype.removeEventListener = function (type, callback, options) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  try {\n    SuperEventTarget.prototype.removeEventListener.call(this, type, callback, options);\n  } catch (e) {\n    // Not a native event target\n  }\n\n  if (!(type in this._listeners)) {\n    return;\n  }\n\n  var stack = this._listeners[type];\n\n  for (var i = 0, l = stack.length; i < l; i++) {\n    if (stack[i] === callback) {\n      stack.splice(i, 1);\n      return;\n    }\n  }\n};\n\nEventTarget.prototype.dispatchEvent = function (event) {\n  var _this = this;\n\n  if (!event) {\n    throw TypeError('Event must be provided');\n  }\n\n  if (!(event instanceof Event)) {\n    throw TypeError('First argument must be an event');\n  }\n\n  if (!(event.type in this._listeners)) {\n    return true;\n  }\n\n  var stack = this._listeners[event.type];\n\n  Object.defineProperty(event, 'target', {\n    configurable: true,\n    get: function get() {\n      return _this;\n    }\n  });\n\n  for (var i = 0, l = stack.length; i < l; i++) {\n    stack[i].call(this, event);\n  }\n\n  return !event.defaultPrevented;\n};\n\nEventTarget.prototype.silence = function (fn) {\n  if (this._silenced) return;\n\n  this._silenced = true;\n  var dispatchEvent = this.dispatchEvent;\n  var result = void 0;\n\n  try {\n    this.dispatchEvent = Function();\n    result = fn.call(this);\n  } finally {\n    this._silenced = false;\n    this.dispatchEvent = dispatchEvent;\n  }\n\n  return result;\n};\n\nEventTarget.prototype.queueEvent = function (eventName, onQueue, onDequeue) {\n  var _this2 = this;\n\n  if (this._pendingEvents[eventName] || this._silenced) return;\n\n  onQueue = onQueue || Function();\n  onDequeue = onDequeue || Function();\n  var detail = {};\n\n  onQueue(detail);\n\n  var immediate = (0, _utils.setImmediate)(function () {\n    delete _this2._pendingEvents[eventName];\n\n    onDequeue(detail);\n\n    _this2.dispatchEvent(new _custom_event2.default(eventName, { detail: detail }));\n  });\n\n  this._pendingEvents[eventName] = immediate;\n};\n\nEventTarget.prototype.clearEvent = function (eventName) {\n  var immediate = this._pendingEvents[eventName];\n\n  if (!immediate) return;\n\n  (0, _utils.clearImmediate)(immediate);\n\n  delete this._pendingEvents[eventName];\n};\n\nexports.default = EventTarget;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _custom_event = __webpack_require__(0);\n\nvar _custom_event2 = _interopRequireDefault(_custom_event);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EventsMap = function () {\n  function EventsMap() {\n    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n\n    _classCallCheck(this, EventsMap);\n\n    this._context = context;\n    this._bubbleEventsMap = new Map();\n    this._captureEventsMap = new Map();\n  }\n\n  _createClass(EventsMap, [{\n    key: 'on',\n    value: function on(eventTarget, eventName, eventHandler, useCapture) {\n      if (typeof eventTarget == 'string') {\n        useCapture = eventHandler;\n        eventHandler = eventName;\n        eventName = eventTarget;\n        eventTarget = this._context;\n      }\n\n      if (!eventTarget) {\n        throw TypeError('An event target must be provided');\n      }\n\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (!eventName) {\n        throw TypeError('An event name must be provided');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      if (!eventHandler) {\n        throw TypeError('An event handler must be provided');\n      }\n\n      if (typeof eventHandler != 'function') {\n        throw TypeError('The third argument must be a function');\n      }\n\n      useCapture = !!useCapture;\n      var eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n      var handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        handlersMap = new Map();\n        eventsMap.set(eventTarget, handlersMap);\n      }\n\n      var boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        boundHandlersMap = new Map();\n        handlersMap.set(eventName, boundHandlersMap);\n      }\n\n      var boundEventHandler = eventHandler.bind(this._context);\n\n      boundHandlersMap.set(eventHandler, boundEventHandler);\n\n      eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n    }\n  }, {\n    key: 'once',\n    value: function once(eventTarget, eventName, eventHandler, useCapture) {\n      var _this = this;\n\n      if (typeof eventTarget == 'string') {\n        useCapture = eventHandler;\n        eventHandler = eventName;\n        eventName = eventTarget;\n        eventTarget = this._context;\n      }\n\n      if (!eventTarget) {\n        throw TypeError('An event target must be provided');\n      }\n\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (!eventName) {\n        throw TypeError('An event name must be provided');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      if (!eventHandler) {\n        throw TypeError('An event handler must be provided');\n      }\n\n      if (typeof eventHandler != 'function') {\n        throw TypeError('The third argument must be a function');\n      }\n\n      useCapture = !!useCapture;\n      var eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n      var handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        handlersMap = new Map();\n        eventsMap.set(eventTarget, handlersMap);\n      }\n\n      var boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        boundHandlersMap = new Map();\n        handlersMap.set(eventName, boundHandlersMap);\n      }\n\n      var boundEventHandler = function boundEventHandler() {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this.off(eventTarget, eventName, eventHandler, useCapture);\n\n        return eventHandler.apply(_this._context, args);\n      };\n\n      boundHandlersMap.set(eventHandler, boundEventHandler);\n\n      eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n    }\n  }, {\n    key: 'off',\n    value: function off(eventTarget, eventName, eventHandler, useCapture) {\n      if (typeof eventTarget == 'string') {\n        useCapture = eventHandler;\n        eventHandler = eventName;\n        eventName = eventTarget;\n        eventTarget = this._context;\n      }\n\n      var eventTargetExists = eventTarget instanceof EventTarget;\n      var eventNameExists = typeof eventName == 'string';\n      var eventHandlerExists = typeof eventHandler == 'function';\n\n      if (eventTargetExists && eventNameExists && eventHandlerExists) {\n        useCapture = !!arguments[3];\n\n        var eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        var handlersMap = eventsMap.get(eventTarget);\n\n        if (!handlersMap) {\n          console.warn('Handlers map not found');\n          return;\n        }\n\n        var boundHandlersMap = handlersMap.get(eventName);\n\n        if (!boundHandlersMap) {\n          console.warn('Bound handlers map not found');\n          return;\n        }\n\n        var boundEventHandler = boundHandlersMap.get(eventHandler);\n\n        if (!boundEventHandler) {\n          console.warn('Bound event handler not found');\n          return;\n        }\n\n        boundHandlersMap.delete(eventHandler);\n\n        if (boundHandlersMap.size == 0) {\n          handlersMap.delete(eventName);\n        }\n\n        if (handlersMap.size == 0) {\n          eventsMap.delete(eventTarget);\n        }\n\n        eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n      } else if (eventTargetExists && eventNameExists) {\n        if (!(eventTarget instanceof EventTarget)) {\n          throw TypeError('The first argument must be an event target');\n        }\n\n        if (typeof eventName != 'string') {\n          throw TypeError('The second argument must be a string');\n        }\n\n        useCapture = !!arguments[2];\n\n        var _eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        var _handlersMap = _eventsMap.get(eventTarget);\n\n        if (!_handlersMap) {\n          console.warn('Handlers map not found');\n          return;\n        }\n\n        var _boundHandlersMap = _handlersMap.get(eventName);\n\n        if (!_boundHandlersMap) {\n          console.warn('Bound handlers map not found');\n          return;\n        }\n\n        _handlersMap.delete(eventName);\n\n        if (_handlersMap.size == 0) {\n          _eventsMap.delete(eventTarget);\n        }\n\n        _boundHandlersMap.forEach(function (boundEventHandler, eventHandler) {\n          _boundHandlersMap.delete(eventHandler);\n\n          eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n        });\n      } else if (eventTargetExists) {\n        if (!(eventTarget instanceof EventTarget)) {\n          throw TypeError('The first argument must be an event target');\n        }\n\n        useCapture = !!arguments[1];\n\n        var _eventsMap2 = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        var _handlersMap2 = _eventsMap2.get(eventTarget);\n\n        if (!_handlersMap2) {\n          console.warn('Handlers map not found');\n          return;\n        }\n\n        _eventsMap2.delete(eventTarget);\n\n        _handlersMap2.forEach(function (boundHandlersMap, eventName) {\n          _handlersMap2.delete(eventName);\n\n          boundHandlersMap.forEach(function (boundEventHandler, eventHandler) {\n            boundHandlersMap.delete(eventHandler);\n\n            eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n          });\n        });\n      } else {\n        useCapture = !!arguments[0];\n\n        var _eventsMap3 = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        _eventsMap3.forEach(function (handlersMap, eventTarget) {\n          _eventsMap3.delete(eventTarget);\n\n          handlersMap.forEach(function (boundHandlersMap, eventName) {\n            handlersMap.delete(eventName);\n\n            boundHandlersMap.forEach(function (boundEventHandler, eventHandler) {\n              boundHandlersMap.delete(eventHandler);\n\n              eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n            });\n          });\n        });\n      }\n    }\n  }, {\n    key: 'emit',\n    value: function emit(eventTarget, eventName, eventParams) {\n      if (typeof eventTarget == 'string') {\n        eventParams = eventName;\n        eventName = eventTarget;\n        eventTarget = this._context;\n      }\n\n      if (!eventTarget) {\n        throw TypeError('An event target must be provided');\n      }\n\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (!eventName) {\n        throw TypeError('An event name must be provided');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      var event = new _custom_event2.default(eventName, eventParams);\n\n      eventTarget.dispatchEvent(event);\n    }\n  }]);\n\n  return EventsMap;\n}();\n\nexports.default = EventsMap;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\nfunction setImmediate(fn) {\n  return (window.setImmediate || setTimeout)(fn);\n}\n\nfunction clearImmediate(id) {\n  return (window.clearImmediate || clearTimeout)(id);\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// events_map.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c16dc76038d000ef9cdf","function CustomEvent(eventName, eventParams = {}) {\n  if (!eventName) {\n    throw TypeError('Event name must be provided');\n  }\n\n  if (typeof eventName != 'string') {\n    throw TypeError('Event name must be a string');\n  }\n\n  if (!(eventParams instanceof Object)) {\n    throw TypeError('Event parameters must be an object');\n  }\n\n  Object.assign({\n    bubbles: true,\n    cancelable: true,\n    detail: {}\n  }, eventParams);\n\n  const self = document.createEvent('CustomEvent');\n\n  self.initCustomEvent(\n    eventName,\n    eventParams.bubbles,\n    eventParams.cancelable,\n    eventParams.detail\n  );\n\n  return self;\n}\n\nCustomEvent.prototype = Object.create(window.Event.prototype);\nCustomEvent.prototype.constructor = CustomEvent;\n\nexport default CustomEvent;\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom_event.js","export { default } from './events_map';\nexport { default as CustomEvent } from './custom_event';\nexport { default as EventTarget } from './event_target';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import CustomEvent from './custom_event';\nimport { clearImmediate, setImmediate } from './utils';\n\nconst SuperEventTarget = window.EventTarget;\n\nfunction EventTarget() {\n  this._listeners = {};\n  this._pendingEvents = {};\n}\n\nEventTarget.prototype = Object.create(SuperEventTarget.prototype);\nEventTarget.prototype.constructor = EventTarget;\n\nEventTarget.prototype.addEventListener = function (type, callback, options) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  try {\n    SuperEventTarget.prototype.addEventListener.call(this, type, callback, options);\n  }\n  catch (e) {\n    // Not a native event target\n  }\n\n  if (!(type in this._listeners)) {\n    this._listeners[type] = [];\n  }\n\n  this._listeners[type].push(callback);\n}\n\nEventTarget.prototype.removeEventListener = function (type, callback, options) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  try {\n    SuperEventTarget.prototype.removeEventListener.call(this, type, callback, options);\n  }\n  catch (e) {\n    // Not a native event target\n  }\n\n  if (!(type in this._listeners)) {\n    return;\n  }\n\n  const stack = this._listeners[type];\n\n  for (let i = 0, l = stack.length; i < l; i++) {\n    if (stack[i] === callback){\n      stack.splice(i, 1);\n      return;\n    }\n  }\n}\n\nEventTarget.prototype.dispatchEvent = function (event) {\n  if (!event) {\n    throw TypeError('Event must be provided');\n  }\n\n  if (!(event instanceof Event)) {\n    throw TypeError('First argument must be an event');\n  }\n\n  if (!(event.type in this._listeners)) {\n    return true;\n  }\n\n  const stack = this._listeners[event.type];\n\n  Object.defineProperty(event, 'target', {\n    configurable: true,\n    get: () => this\n  });\n\n  for (let i = 0, l = stack.length; i < l; i++) {\n    stack[i].call(this, event);\n  }\n\n  return !event.defaultPrevented;\n}\n\nEventTarget.prototype.silence = function (fn) {\n  if (this._silenced) return;\n\n  this._silenced = true;\n  const dispatchEvent = this.dispatchEvent;\n  let result;\n\n  try {\n    this.dispatchEvent = Function();\n    result = fn.call(this);\n  }\n  finally {\n    this._silenced = false;\n    this.dispatchEvent = dispatchEvent;\n  }\n\n  return result;\n};\n\nEventTarget.prototype.queueEvent = function (eventName, onQueue, onDequeue) {\n  if (this._pendingEvents[eventName] || this._silenced) return;\n\n  onQueue = onQueue || Function();\n  onDequeue = onDequeue || Function();\n  const detail = {};\n\n  onQueue(detail);\n\n  const immediate = setImmediate(() => {\n    delete this._pendingEvents[eventName];\n\n    onDequeue(detail);\n\n    this.dispatchEvent(new CustomEvent(eventName, { detail }));\n  });\n\n  this._pendingEvents[eventName] = immediate;\n};\n\nEventTarget.prototype.clearEvent = function (eventName) {\n  const immediate = this._pendingEvents[eventName];\n\n  if (!immediate) return;\n\n  clearImmediate(immediate);\n\n  delete this._pendingEvents[eventName];\n};\n\nexport default EventTarget;\n\n\n\n// WEBPACK FOOTER //\n// ./src/event_target.js","import CustomEvent from './custom_event';\n\nclass EventsMap {\n  constructor(context = window) {\n    this._context = context;\n    this._bubbleEventsMap = new Map();\n    this._captureEventsMap = new Map();\n  }\n\n  on(eventTarget, eventName, eventHandler, useCapture) {\n    if (typeof eventTarget == 'string') {\n      useCapture = eventHandler;\n      eventHandler = eventName;\n      eventName = eventTarget;\n      eventTarget = this._context;\n    }\n\n    if (!eventTarget) {\n      throw TypeError('An event target must be provided');\n    }\n\n    if (!(eventTarget instanceof EventTarget)) {\n      throw TypeError('The first argument must be an event target');\n    }\n\n    if (!eventName) {\n      throw TypeError('An event name must be provided');\n    }\n\n    if (typeof eventName != 'string') {\n      throw TypeError('The second argument must be a string');\n    }\n\n    if (!eventHandler) {\n      throw TypeError('An event handler must be provided');\n    }\n\n    if (typeof eventHandler != 'function') {\n      throw TypeError('The third argument must be a function');\n    }\n\n    useCapture = !!useCapture;\n    const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n    let handlersMap = eventsMap.get(eventTarget);\n\n    if (!handlersMap) {\n      handlersMap = new Map();\n      eventsMap.set(eventTarget, handlersMap);\n    }\n\n    let boundHandlersMap = handlersMap.get(eventName);\n\n    if (!boundHandlersMap) {\n      boundHandlersMap = new Map();\n      handlersMap.set(eventName, boundHandlersMap);\n    }\n\n    const boundEventHandler = eventHandler.bind(this._context);\n\n    boundHandlersMap.set(eventHandler, boundEventHandler);\n\n    eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n  }\n\n  once(eventTarget, eventName, eventHandler, useCapture) {\n    if (typeof eventTarget == 'string') {\n      useCapture = eventHandler;\n      eventHandler = eventName;\n      eventName = eventTarget;\n      eventTarget = this._context;\n    }\n\n    if (!eventTarget) {\n      throw TypeError('An event target must be provided');\n    }\n\n    if (!(eventTarget instanceof EventTarget)) {\n      throw TypeError('The first argument must be an event target');\n    }\n\n    if (!eventName) {\n      throw TypeError('An event name must be provided');\n    }\n\n    if (typeof eventName != 'string') {\n      throw TypeError('The second argument must be a string');\n    }\n\n    if (!eventHandler) {\n      throw TypeError('An event handler must be provided');\n    }\n\n    if (typeof eventHandler != 'function') {\n      throw TypeError('The third argument must be a function');\n    }\n\n    useCapture = !!useCapture;\n    const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n    let handlersMap = eventsMap.get(eventTarget);\n\n    if (!handlersMap) {\n      handlersMap = new Map();\n      eventsMap.set(eventTarget, handlersMap);\n    }\n\n    let boundHandlersMap = handlersMap.get(eventName);\n\n    if (!boundHandlersMap) {\n      boundHandlersMap = new Map();\n      handlersMap.set(eventName, boundHandlersMap);\n    }\n\n    const boundEventHandler = (...args) => {\n      this.off(eventTarget, eventName, eventHandler, useCapture);\n\n      return eventHandler.apply(this._context, args);\n    };\n\n    boundHandlersMap.set(eventHandler, boundEventHandler);\n\n    eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n  }\n\n  off(eventTarget, eventName, eventHandler, useCapture) {\n    if (typeof eventTarget == 'string') {\n      useCapture = eventHandler;\n      eventHandler = eventName;\n      eventName = eventTarget;\n      eventTarget = this._context;\n    }\n\n    let eventTargetExists = eventTarget instanceof EventTarget;\n    let eventNameExists = typeof eventName == 'string';\n    let eventHandlerExists = typeof eventHandler == 'function';\n\n    if (eventTargetExists && eventNameExists && eventHandlerExists) {\n      useCapture = !!arguments[3];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      const handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        console.warn('Handlers map not found');\n        return;\n      }\n\n      const boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        console.warn('Bound handlers map not found');\n        return;\n      }\n\n      const boundEventHandler = boundHandlersMap.get(eventHandler);\n\n      if (!boundEventHandler) {\n        console.warn('Bound event handler not found');\n        return;\n      }\n\n      boundHandlersMap.delete(eventHandler);\n\n      if (boundHandlersMap.size == 0) {\n        handlersMap.delete(eventName);\n      }\n\n      if (handlersMap.size == 0) {\n        eventsMap.delete(eventTarget);\n      }\n\n      eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n    }\n    else if (eventTargetExists && eventNameExists) {\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      useCapture = !!arguments[2];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      const handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        console.warn('Handlers map not found');\n        return;\n      }\n\n      const boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        console.warn('Bound handlers map not found');\n        return;\n      }\n\n      handlersMap.delete(eventName);\n\n      if (handlersMap.size == 0) {\n        eventsMap.delete(eventTarget);\n      }\n\n      boundHandlersMap.forEach((boundEventHandler, eventHandler) => {\n        boundHandlersMap.delete(eventHandler);\n\n        eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n      });\n    }\n    else if (eventTargetExists) {\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      useCapture = !!arguments[1];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      const handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        console.warn('Handlers map not found');\n        return;\n      }\n\n      eventsMap.delete(eventTarget);\n\n      handlersMap.forEach((boundHandlersMap, eventName) => {\n        handlersMap.delete(eventName);\n\n        boundHandlersMap.forEach((boundEventHandler, eventHandler) => {\n          boundHandlersMap.delete(eventHandler);\n\n          eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n        });\n      });\n    }\n    else {\n      useCapture = !!arguments[0];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      eventsMap.forEach((handlersMap, eventTarget) => {\n        eventsMap.delete(eventTarget);\n\n        handlersMap.forEach((boundHandlersMap, eventName) => {\n          handlersMap.delete(eventName);\n\n          boundHandlersMap.forEach((boundEventHandler, eventHandler) => {\n            boundHandlersMap.delete(eventHandler);\n\n            eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n          });\n        });\n      });\n    }\n  }\n\n  emit(eventTarget, eventName, eventParams) {\n    if (typeof eventTarget == 'string') {\n      eventParams = eventName;\n      eventName = eventTarget;\n      eventTarget = this._context;\n    }\n\n    if (!eventTarget) {\n      throw TypeError('An event target must be provided');\n    }\n\n    if (!(eventTarget instanceof EventTarget)) {\n      throw TypeError('The first argument must be an event target');\n    }\n\n    if (!eventName) {\n      throw TypeError('An event name must be provided');\n    }\n\n    if (typeof eventName != 'string') {\n      throw TypeError('The second argument must be a string');\n    }\n\n    const event = new CustomEvent(eventName, eventParams);\n\n    eventTarget.dispatchEvent(event);\n  }\n}\n\nexport default EventsMap;\n\n\n\n// WEBPACK FOOTER //\n// ./src/events_map.js","export function setImmediate(fn) {\n  return (window.setImmediate || setTimeout)(fn);\n}\n\nexport function clearImmediate(id) {\n  return (window.clearImmediate || clearTimeout)(id);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js"],"sourceRoot":""}