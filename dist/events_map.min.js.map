{"version":3,"sources":["webpack:///events_map.min.js","webpack:///webpack/bootstrap 0d7d753056f0f6243c85","webpack:///./src/custom_event.js","webpack:///./src/index.js","webpack:///./src/event_target.js","webpack:///./src/events_map.js","webpack:///./src/utils.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","CustomEvent","eventName","eventParams","arguments","length","undefined","TypeError","assign","bubbles","cancelable","detail","self","document","createEvent","initCustomEvent","create","window","Event","constructor","default","_interopRequireDefault","obj","_events_map","_custom_event","_event_target","EventTarget","this","_listeners","_pendingEvents","_custom_event2","_utils","addEventListener","type","callback","push","removeEventListener","stack","splice","dispatchEvent","event","_this","defaultPrevented","silence","fn","_silenced","result","Function","queueEvent","onQueue","onDequeue","_this2","immediate","setImmediate","clearEvent","clearImmediate","_classCallCheck","instance","Constructor","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","EventsMap","context","_context","_bubbleEventsMap","Map","_captureEventsMap","eventTarget","eventHandler","useCapture","eventsMap","handlersMap","set","boundHandlersMap","boundEventHandler","bind","_len","args","Array","_key","off","apply","eventTargetExists","eventNameExists","eventHandlerExists","console","warn","delete","size","forEach","setTimeout","id","clearTimeout"],"mappings":"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","file":"events_map.min.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction CustomEvent(eventName) {\n  var eventParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!eventName) {\n    throw TypeError('Event name must be provided');\n  }\n\n  if (typeof eventName != 'string') {\n    throw TypeError('Event name must be a string');\n  }\n\n  if (!(eventParams instanceof Object)) {\n    throw TypeError('Event parameters must be an object');\n  }\n\n  Object.assign({\n    bubbles: true,\n    cancelable: true,\n    detail: {}\n  }, eventParams);\n\n  var self = document.createEvent('CustomEvent');\n\n  self.initCustomEvent(eventName, eventParams.bubbles, eventParams.cancelable, eventParams.detail);\n\n  return self;\n}\n\nCustomEvent.prototype = Object.create(window.Event.prototype);\nCustomEvent.prototype.constructor = CustomEvent;\n\nexports.default = CustomEvent;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _events_map = __webpack_require__(3);\n\nObject.defineProperty(exports, 'default', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_events_map).default;\n  }\n});\n\nvar _custom_event = __webpack_require__(0);\n\nObject.defineProperty(exports, 'CustomEvent', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_custom_event).default;\n  }\n});\n\nvar _event_target = __webpack_require__(2);\n\nObject.defineProperty(exports, 'EventTarget', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_event_target).default;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _custom_event = __webpack_require__(0);\n\nvar _custom_event2 = _interopRequireDefault(_custom_event);\n\nvar _utils = __webpack_require__(4);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction EventTarget() {\n  this._listeners = {};\n  this._pendingEvents = {};\n}\n\nEventTarget.prototype = Object.create(window.EventTarget.prototype);\nEventTarget.prototype.constructor = EventTarget;\n\nEventTarget.prototype.addEventListener = function addEventListener(type, callback) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  if (!(type in this._listeners)) {\n    this._listeners[type] = [];\n  }\n\n  this._listeners[type].push(callback);\n};\n\nEventTarget.prototype.removeEventListener = function removeEventListener(type, callback) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  if (!(type in this._listeners)) {\n    return;\n  }\n\n  var stack = this._listeners[type];\n\n  for (var i = 0, l = stack.length; i < l; i++) {\n    if (stack[i] === callback) {\n      stack.splice(i, 1);\n      return;\n    }\n  }\n};\n\nEventTarget.prototype.dispatchEvent = function dispatchEvent(event) {\n  var _this = this;\n\n  if (!event) {\n    throw TypeError('Event must be provided');\n  }\n\n  if (!(event instanceof Event)) {\n    throw TypeError('First argument must be an event');\n  }\n\n  if (!(event.type in this._listeners)) {\n    return true;\n  }\n\n  var stack = this._listeners[event.type];\n\n  Object.defineProperty(event, 'target', {\n    configurable: true,\n    get: function get() {\n      return _this;\n    }\n  });\n\n  for (var i = 0, l = stack.length; i < l; i++) {\n    stack[i].call(this, event);\n  }\n\n  return !event.defaultPrevented;\n};\n\nEventTarget.prototype.silence = function silence(fn) {\n  if (this._silenced) return;\n\n  this._silenced = true;\n  var dispatchEvent = this.dispatchEvent;\n  var result = void 0;\n\n  try {\n    this.dispatchEvent = Function();\n    result = fn.call(this);\n  } finally {\n    this._silenced = false;\n    this.dispatchEvent = dispatchEvent;\n  }\n\n  return result;\n};\n\nEventTarget.prototype.queueEvent = function queueEvent(eventName, onQueue, onDequeue) {\n  var _this2 = this;\n\n  if (this._pendingEvents[eventName] || this._silenced) return;\n\n  onQueue = onQueue || Function();\n  onDequeue = onDequeue || Function();\n  var detail = {};\n\n  onQueue(detail);\n\n  var immediate = (0, _utils.setImmediate)(function () {\n    delete _this2._pendingEvents[eventName];\n\n    onDequeue(detail);\n\n    _this2.dispatchEvent(new _custom_event2.default(eventName, { detail: detail }));\n  });\n\n  this._pendingEvents[eventName] = immediate;\n};\n\nEventTarget.prototype.clearEvent = function clearEvent(eventName) {\n  var immediate = this._pendingEvents[eventName];\n\n  if (!immediate) return;\n\n  (0, _utils.clearImmediate)(immediate);\n\n  delete this._pendingEvents[eventName];\n};\n\nexports.default = EventTarget;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _custom_event = __webpack_require__(0);\n\nvar _custom_event2 = _interopRequireDefault(_custom_event);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EventsMap = function () {\n  function EventsMap() {\n    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n\n    _classCallCheck(this, EventsMap);\n\n    this._context = context;\n    this._bubbleEventsMap = new Map();\n    this._captureEventsMap = new Map();\n  }\n\n  _createClass(EventsMap, [{\n    key: 'on',\n    value: function on(eventTarget, eventName, eventHandler, useCapture) {\n      if (typeof eventTarget == 'string') {\n        useCapture = eventHandler;\n        eventHandler = eventName;\n        eventName = eventTarget;\n        eventTarget = this._context;\n      }\n\n      if (!eventTarget) {\n        throw TypeError('An event target must be provided');\n      }\n\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (!eventName) {\n        throw TypeError('An event name must be provided');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      if (!eventHandler) {\n        throw TypeError('An event handler must be provided');\n      }\n\n      if (typeof eventHandler != 'function') {\n        throw TypeError('The third argument must be a function');\n      }\n\n      useCapture = !!useCapture;\n      var eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n      var handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        handlersMap = new Map();\n        eventsMap.set(eventTarget, handlersMap);\n      }\n\n      var boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        boundHandlersMap = new Map();\n        handlersMap.set(eventName, boundHandlersMap);\n      }\n\n      var boundEventHandler = eventHandler.bind(this._context);\n\n      boundHandlersMap.set(eventHandler, boundEventHandler);\n\n      eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n    }\n  }, {\n    key: 'once',\n    value: function once(eventTarget, eventName, eventHandler, useCapture) {\n      var _this = this;\n\n      if (typeof eventTarget == 'string') {\n        useCapture = eventHandler;\n        eventHandler = eventName;\n        eventName = eventTarget;\n        eventTarget = this._context;\n      }\n\n      if (!eventTarget) {\n        throw TypeError('An event target must be provided');\n      }\n\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (!eventName) {\n        throw TypeError('An event name must be provided');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      if (!eventHandler) {\n        throw TypeError('An event handler must be provided');\n      }\n\n      if (typeof eventHandler != 'function') {\n        throw TypeError('The third argument must be a function');\n      }\n\n      useCapture = !!useCapture;\n      var eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n      var handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        handlersMap = new Map();\n        eventsMap.set(eventTarget, handlersMap);\n      }\n\n      var boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        boundHandlersMap = new Map();\n        handlersMap.set(eventName, boundHandlersMap);\n      }\n\n      var boundEventHandler = function boundEventHandler() {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this.off(eventTarget, eventName, eventHandler, useCapture);\n\n        return eventHandler.apply(_this._context, args);\n      };\n\n      boundHandlersMap.set(eventHandler, boundEventHandler);\n\n      eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n    }\n  }, {\n    key: 'off',\n    value: function off(eventTarget, eventName, eventHandler, useCapture) {\n      if (typeof eventTarget == 'string') {\n        useCapture = eventHandler;\n        eventHandler = eventName;\n        eventName = eventTarget;\n        eventTarget = this._context;\n      }\n\n      var eventTargetExists = eventTarget instanceof EventTarget;\n      var eventNameExists = typeof eventName == 'string';\n      var eventHandlerExists = typeof eventHandler == 'function';\n\n      if (eventTargetExists && eventNameExists && eventHandlerExists) {\n        useCapture = !!arguments[3];\n\n        var eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        var handlersMap = eventsMap.get(eventTarget);\n\n        if (!handlersMap) {\n          console.warn('Handlers map not found');\n          return;\n        }\n\n        var boundHandlersMap = handlersMap.get(eventName);\n\n        if (!boundHandlersMap) {\n          console.warn('Bound handlers map not found');\n          return;\n        }\n\n        var boundEventHandler = boundHandlersMap.get(eventHandler);\n\n        if (!boundEventHandler) {\n          console.warn('Bound event handler not found');\n          return;\n        }\n\n        boundHandlersMap.delete(eventHandler);\n\n        if (boundHandlersMap.size == 0) {\n          handlersMap.delete(eventName);\n        }\n\n        if (handlersMap.size == 0) {\n          eventsMap.delete(eventTarget);\n        }\n\n        eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n      } else if (eventTargetExists && eventNameExists) {\n        if (!(eventTarget instanceof EventTarget)) {\n          throw TypeError('The first argument must be an event target');\n        }\n\n        if (typeof eventName != 'string') {\n          throw TypeError('The second argument must be a string');\n        }\n\n        useCapture = !!arguments[2];\n\n        var _eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        var _handlersMap = _eventsMap.get(eventTarget);\n\n        if (!_handlersMap) {\n          console.warn('Handlers map not found');\n          return;\n        }\n\n        var _boundHandlersMap = _handlersMap.get(eventName);\n\n        if (!_boundHandlersMap) {\n          console.warn('Bound handlers map not found');\n          return;\n        }\n\n        _handlersMap.delete(eventName);\n\n        if (_handlersMap.size == 0) {\n          _eventsMap.delete(eventTarget);\n        }\n\n        _boundHandlersMap.forEach(function (boundEventHandler, eventHandler) {\n          _boundHandlersMap.delete(eventHandler);\n\n          eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n        });\n      } else if (eventTargetExists) {\n        if (!(eventTarget instanceof EventTarget)) {\n          throw TypeError('The first argument must be an event target');\n        }\n\n        useCapture = !!arguments[1];\n\n        var _eventsMap2 = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        var _handlersMap2 = _eventsMap2.get(eventTarget);\n\n        if (!_handlersMap2) {\n          console.warn('Handlers map not found');\n          return;\n        }\n\n        _eventsMap2.delete(eventTarget);\n\n        _handlersMap2.forEach(function (boundHandlersMap, eventName) {\n          _handlersMap2.delete(eventName);\n\n          boundHandlersMap.forEach(function (boundEventHandler, eventHandler) {\n            boundHandlersMap.delete(eventHandler);\n\n            eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n          });\n        });\n      } else {\n        useCapture = !!arguments[0];\n\n        var _eventsMap3 = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        _eventsMap3.forEach(function (handlersMap, eventTarget) {\n          _eventsMap3.delete(eventTarget);\n\n          handlersMap.forEach(function (boundHandlersMap, eventName) {\n            handlersMap.delete(eventName);\n\n            boundHandlersMap.forEach(function (boundEventHandler, eventHandler) {\n              boundHandlersMap.delete(eventHandler);\n\n              eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n            });\n          });\n        });\n      }\n    }\n  }, {\n    key: 'emit',\n    value: function emit(eventTarget, eventName, eventParams) {\n      if (typeof eventTarget == 'string') {\n        eventParams = eventName;\n        eventName = eventTarget;\n        eventTarget = this._context;\n      }\n\n      if (!eventTarget) {\n        throw TypeError('An event target must be provided');\n      }\n\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (!eventName) {\n        throw TypeError('An event name must be provided');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      var event = new _custom_event2.default(eventName, eventParams);\n\n      eventTarget.dispatchEvent(event);\n    }\n  }]);\n\n  return EventsMap;\n}();\n\nexports.default = EventsMap;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\nfunction setImmediate(fn) {\n  return (window.setImmediate || setTimeout)(fn);\n}\n\nfunction clearImmediate(id) {\n  return (window.clearImmediate || clearTimeout)(id);\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// events_map.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0d7d753056f0f6243c85","function CustomEvent(eventName, eventParams = {}) {\n  if (!eventName) {\n    throw TypeError('Event name must be provided');\n  }\n\n  if (typeof eventName != 'string') {\n    throw TypeError('Event name must be a string');\n  }\n\n  if (!(eventParams instanceof Object)) {\n    throw TypeError('Event parameters must be an object');\n  }\n\n  Object.assign({\n    bubbles: true,\n    cancelable: true,\n    detail: {}\n  }, eventParams);\n\n  const self = document.createEvent('CustomEvent');\n\n  self.initCustomEvent(\n    eventName,\n    eventParams.bubbles,\n    eventParams.cancelable,\n    eventParams.detail\n  );\n\n  return self;\n}\n\nCustomEvent.prototype = Object.create(window.Event.prototype);\nCustomEvent.prototype.constructor = CustomEvent;\n\nexport default CustomEvent;\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom_event.js","export { default } from './events_map';\nexport { default as CustomEvent } from './custom_event';\nexport { default as EventTarget } from './event_target';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import CustomEvent from './custom_event';\nimport { clearImmediate, setImmediate } from './utils';\n\nfunction EventTarget() {\n  this._listeners = {};\n  this._pendingEvents = {};\n}\n\nEventTarget.prototype = Object.create(window.EventTarget.prototype);\nEventTarget.prototype.constructor = EventTarget;\n\nEventTarget.prototype.addEventListener = function addEventListener(type, callback) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  if (!(type in this._listeners)) {\n    this._listeners[type] = [];\n  }\n\n  this._listeners[type].push(callback);\n}\n\nEventTarget.prototype.removeEventListener = function removeEventListener(type, callback) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  if (!(type in this._listeners)) {\n    return;\n  }\n\n  const stack = this._listeners[type];\n\n  for (let i = 0, l = stack.length; i < l; i++) {\n    if (stack[i] === callback){\n      stack.splice(i, 1);\n      return;\n    }\n  }\n}\n\nEventTarget.prototype.dispatchEvent = function dispatchEvent(event) {\n  if (!event) {\n    throw TypeError('Event must be provided');\n  }\n\n  if (!(event instanceof Event)) {\n    throw TypeError('First argument must be an event');\n  }\n\n  if (!(event.type in this._listeners)) {\n    return true;\n  }\n\n  const stack = this._listeners[event.type];\n\n  Object.defineProperty(event, 'target', {\n    configurable: true,\n    get: () => this\n  });\n\n  for (let i = 0, l = stack.length; i < l; i++) {\n    stack[i].call(this, event);\n  }\n\n  return !event.defaultPrevented;\n}\n\nEventTarget.prototype.silence = function silence(fn) {\n  if (this._silenced) return;\n\n  this._silenced = true;\n  const dispatchEvent = this.dispatchEvent;\n  let result;\n\n  try {\n    this.dispatchEvent = Function();\n    result = fn.call(this);\n  }\n  finally {\n    this._silenced = false;\n    this.dispatchEvent = dispatchEvent;\n  }\n\n  return result;\n};\n\nEventTarget.prototype.queueEvent = function queueEvent(eventName, onQueue, onDequeue) {\n  if (this._pendingEvents[eventName] || this._silenced) return;\n\n  onQueue = onQueue || Function();\n  onDequeue = onDequeue || Function();\n  const detail = {};\n\n  onQueue(detail);\n\n  const immediate = setImmediate(() => {\n    delete this._pendingEvents[eventName];\n\n    onDequeue(detail);\n\n    this.dispatchEvent(new CustomEvent(eventName, { detail }));\n  });\n\n  this._pendingEvents[eventName] = immediate;\n};\n\nEventTarget.prototype.clearEvent = function clearEvent(eventName) {\n  const immediate = this._pendingEvents[eventName];\n\n  if (!immediate) return;\n\n  clearImmediate(immediate);\n\n  delete this._pendingEvents[eventName];\n};\n\nexport default EventTarget;\n\n\n\n// WEBPACK FOOTER //\n// ./src/event_target.js","import CustomEvent from './custom_event';\n\nclass EventsMap {\n  constructor(context = window) {\n    this._context = context;\n    this._bubbleEventsMap = new Map();\n    this._captureEventsMap = new Map();\n  }\n\n  on(eventTarget, eventName, eventHandler, useCapture) {\n    if (typeof eventTarget == 'string') {\n      useCapture = eventHandler;\n      eventHandler = eventName;\n      eventName = eventTarget;\n      eventTarget = this._context;\n    }\n\n    if (!eventTarget) {\n      throw TypeError('An event target must be provided');\n    }\n\n    if (!(eventTarget instanceof EventTarget)) {\n      throw TypeError('The first argument must be an event target');\n    }\n\n    if (!eventName) {\n      throw TypeError('An event name must be provided');\n    }\n\n    if (typeof eventName != 'string') {\n      throw TypeError('The second argument must be a string');\n    }\n\n    if (!eventHandler) {\n      throw TypeError('An event handler must be provided');\n    }\n\n    if (typeof eventHandler != 'function') {\n      throw TypeError('The third argument must be a function');\n    }\n\n    useCapture = !!useCapture;\n    const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n    let handlersMap = eventsMap.get(eventTarget);\n\n    if (!handlersMap) {\n      handlersMap = new Map();\n      eventsMap.set(eventTarget, handlersMap);\n    }\n\n    let boundHandlersMap = handlersMap.get(eventName);\n\n    if (!boundHandlersMap) {\n      boundHandlersMap = new Map();\n      handlersMap.set(eventName, boundHandlersMap);\n    }\n\n    const boundEventHandler = eventHandler.bind(this._context);\n\n    boundHandlersMap.set(eventHandler, boundEventHandler);\n\n    eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n  }\n\n  once(eventTarget, eventName, eventHandler, useCapture) {\n    if (typeof eventTarget == 'string') {\n      useCapture = eventHandler;\n      eventHandler = eventName;\n      eventName = eventTarget;\n      eventTarget = this._context;\n    }\n\n    if (!eventTarget) {\n      throw TypeError('An event target must be provided');\n    }\n\n    if (!(eventTarget instanceof EventTarget)) {\n      throw TypeError('The first argument must be an event target');\n    }\n\n    if (!eventName) {\n      throw TypeError('An event name must be provided');\n    }\n\n    if (typeof eventName != 'string') {\n      throw TypeError('The second argument must be a string');\n    }\n\n    if (!eventHandler) {\n      throw TypeError('An event handler must be provided');\n    }\n\n    if (typeof eventHandler != 'function') {\n      throw TypeError('The third argument must be a function');\n    }\n\n    useCapture = !!useCapture;\n    const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n    let handlersMap = eventsMap.get(eventTarget);\n\n    if (!handlersMap) {\n      handlersMap = new Map();\n      eventsMap.set(eventTarget, handlersMap);\n    }\n\n    let boundHandlersMap = handlersMap.get(eventName);\n\n    if (!boundHandlersMap) {\n      boundHandlersMap = new Map();\n      handlersMap.set(eventName, boundHandlersMap);\n    }\n\n    const boundEventHandler = (...args) => {\n      this.off(eventTarget, eventName, eventHandler, useCapture);\n\n      return eventHandler.apply(this._context, args);\n    };\n\n    boundHandlersMap.set(eventHandler, boundEventHandler);\n\n    eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n  }\n\n  off(eventTarget, eventName, eventHandler, useCapture) {\n    if (typeof eventTarget == 'string') {\n      useCapture = eventHandler;\n      eventHandler = eventName;\n      eventName = eventTarget;\n      eventTarget = this._context;\n    }\n\n    let eventTargetExists = eventTarget instanceof EventTarget;\n    let eventNameExists = typeof eventName == 'string';\n    let eventHandlerExists = typeof eventHandler == 'function';\n\n    if (eventTargetExists && eventNameExists && eventHandlerExists) {\n      useCapture = !!arguments[3];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      const handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        console.warn('Handlers map not found');\n        return;\n      }\n\n      const boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        console.warn('Bound handlers map not found');\n        return;\n      }\n\n      const boundEventHandler = boundHandlersMap.get(eventHandler);\n\n      if (!boundEventHandler) {\n        console.warn('Bound event handler not found');\n        return;\n      }\n\n      boundHandlersMap.delete(eventHandler);\n\n      if (boundHandlersMap.size == 0) {\n        handlersMap.delete(eventName);\n      }\n\n      if (handlersMap.size == 0) {\n        eventsMap.delete(eventTarget);\n      }\n\n      eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n    }\n    else if (eventTargetExists && eventNameExists) {\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      useCapture = !!arguments[2];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      const handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        console.warn('Handlers map not found');\n        return;\n      }\n\n      const boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        console.warn('Bound handlers map not found');\n        return;\n      }\n\n      handlersMap.delete(eventName);\n\n      if (handlersMap.size == 0) {\n        eventsMap.delete(eventTarget);\n      }\n\n      boundHandlersMap.forEach((boundEventHandler, eventHandler) => {\n        boundHandlersMap.delete(eventHandler);\n\n        eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n      });\n    }\n    else if (eventTargetExists) {\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      useCapture = !!arguments[1];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      const handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        console.warn('Handlers map not found');\n        return;\n      }\n\n      eventsMap.delete(eventTarget);\n\n      handlersMap.forEach((boundHandlersMap, eventName) => {\n        handlersMap.delete(eventName);\n\n        boundHandlersMap.forEach((boundEventHandler, eventHandler) => {\n          boundHandlersMap.delete(eventHandler);\n\n          eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n        });\n      });\n    }\n    else {\n      useCapture = !!arguments[0];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      eventsMap.forEach((handlersMap, eventTarget) => {\n        eventsMap.delete(eventTarget);\n\n        handlersMap.forEach((boundHandlersMap, eventName) => {\n          handlersMap.delete(eventName);\n\n          boundHandlersMap.forEach((boundEventHandler, eventHandler) => {\n            boundHandlersMap.delete(eventHandler);\n\n            eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n          });\n        });\n      });\n    }\n  }\n\n  emit(eventTarget, eventName, eventParams) {\n    if (typeof eventTarget == 'string') {\n      eventParams = eventName;\n      eventName = eventTarget;\n      eventTarget = this._context;\n    }\n\n    if (!eventTarget) {\n      throw TypeError('An event target must be provided');\n    }\n\n    if (!(eventTarget instanceof EventTarget)) {\n      throw TypeError('The first argument must be an event target');\n    }\n\n    if (!eventName) {\n      throw TypeError('An event name must be provided');\n    }\n\n    if (typeof eventName != 'string') {\n      throw TypeError('The second argument must be a string');\n    }\n\n    const event = new CustomEvent(eventName, eventParams);\n\n    eventTarget.dispatchEvent(event);\n  }\n}\n\nexport default EventsMap;\n\n\n\n// WEBPACK FOOTER //\n// ./src/events_map.js","export function setImmediate(fn) {\n  return (window.setImmediate || setTimeout)(fn);\n}\n\nexport function clearImmediate(id) {\n  return (window.clearImmediate || clearTimeout)(id);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js"],"sourceRoot":""}