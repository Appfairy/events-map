{"version":3,"sources":["webpack:///events_map.min.js","webpack:///webpack/bootstrap 7d211064729df7e0ec32","webpack:///./src/custom_event.js","webpack:///./src/event_target.js","webpack:///./src/index.js","webpack:///./src/events_map.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","CustomEvent","eventName","eventParams","arguments","length","undefined","TypeError","assign","bubbles","cancelable","detail","self","document","createEvent","initCustomEvent","create","window","Event","constructor","default","EventTarget","_listeners","setPrototypeOf","this","_custom_event","_custom_event2","obj","emit","eventTarget","event","dispatchEvent","addEventListener","type","callback","push","removeEventListener","stack","splice","_this","defaultPrevented","_interopRequireDefault","_events_map","_event_target","_classCallCheck","instance","Constructor","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","_event_target2","EventsMap","context","_context","_bubbleEventsMap","Map","_captureEventsMap","eventHandler","useCapture","eventsMap","handlersMap","set","boundHandlersMap","boundEventHandler","bind","_len","args","Array","_key","off","apply","eventTargetExists","eventNameExists","eventHandlerExists","console","warn","delete","size","forEach"],"mappings":"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","file":"events_map.min.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 4);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction CustomEvent(eventName) {\n  var eventParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!eventName) {\n    throw TypeError('Event name must be provided');\n  }\n\n  if (typeof eventName != 'string') {\n    throw TypeError('Event name must be a string');\n  }\n\n  if (!(eventParams instanceof Object)) {\n    throw TypeError('Event parameters must be an object');\n  }\n\n  Object.assign({\n    bubbles: true,\n    cancelable: true,\n    detail: {}\n  }, eventParams);\n\n  var self = document.createEvent('CustomEvent');\n\n  self.initCustomEvent(eventName, eventParams.bubbles, eventParams.cancelable, eventParams.detail);\n\n  return self;\n}\n\nCustomEvent.prototype = Object.create(window.Event.prototype);\nCustomEvent.prototype.constructor = CustomEvent;\n\nexports.default = CustomEvent;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _custom_event = __webpack_require__(0);\n\nvar _custom_event2 = _interopRequireDefault(_custom_event);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction EventTarget() {\n  var self = {\n    _listeners: {}\n  };\n\n  Object.setPrototypeOf(self, this.constructor.prototype);\n\n  return self;\n}\n\nEventTarget.prototype = Object.create(window.EventTarget.prototype);\nEventTarget.prototype.constructor = EventTarget;\n\nEventTarget.emit = function emit(eventTarget, eventName, eventParams) {\n  if (!eventTarget) {\n    throw TypeError('An event target must be provided');\n  }\n\n  if (!(eventTarget instanceof window.EventTarget)) {\n    throw TypeError('The first argument must be an event target');\n  }\n\n  if (!eventName) {\n    throw TypeError('An event name must be provided');\n  }\n\n  if (typeof eventName != 'string') {\n    throw TypeError('The second argument must be a string');\n  }\n\n  var event = new _custom_event2.default(eventName, eventParams);\n\n  eventTarget.dispatchEvent(event);\n};\n\nEventTarget.prototype.addEventListener = function addEventListener(type, callback) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  if (!(type in this._listeners)) {\n    this._listeners[type] = [];\n  }\n\n  this._listeners[type].push(callback);\n};\n\nEventTarget.prototype.removeEventListener = function removeEventListener(type, callback) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  if (!(type in this._listeners)) {\n    return;\n  }\n\n  var stack = this._listeners[type];\n\n  for (var i = 0, l = stack.length; i < l; i++) {\n    if (stack[i] === callback) {\n      stack.splice(i, 1);\n      return;\n    }\n  }\n};\n\nEventTarget.prototype.dispatchEvent = function dispatchEvent(event) {\n  var _this = this;\n\n  if (!event) {\n    throw TypeError('Event must be provided');\n  }\n\n  if (!(event instanceof Event)) {\n    throw TypeError('First argument must be an event');\n  }\n\n  if (!(event.type in this._listeners)) {\n    return true;\n  }\n\n  var stack = this._listeners[event.type];\n\n  Object.defineProperty(event, 'target', {\n    configurable: true,\n    get: function get() {\n      return _this;\n    }\n  });\n\n  for (var i = 0, l = stack.length; i < l; i++) {\n    stack[i].call(this, event);\n  }\n\n  return !event.defaultPrevented;\n};\n\nexports.default = EventTarget;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _events_map = __webpack_require__(3);\n\nObject.defineProperty(exports, 'default', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_events_map).default;\n  }\n});\n\nvar _custom_event = __webpack_require__(0);\n\nObject.defineProperty(exports, 'CustomEvent', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_custom_event).default;\n  }\n});\n\nvar _event_target = __webpack_require__(1);\n\nObject.defineProperty(exports, 'EventTarget', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_event_target).default;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _custom_event = __webpack_require__(0);\n\nvar _custom_event2 = _interopRequireDefault(_custom_event);\n\nvar _event_target = __webpack_require__(1);\n\nvar _event_target2 = _interopRequireDefault(_event_target);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EventsMap = function () {\n  function EventsMap() {\n    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n\n    _classCallCheck(this, EventsMap);\n\n    this._context = context;\n    this._bubbleEventsMap = new Map();\n    this._captureEventsMap = new Map();\n  }\n\n  _createClass(EventsMap, [{\n    key: 'on',\n    value: function on(eventTarget, eventName, eventHandler, useCapture) {\n      if (!eventTarget) {\n        throw TypeError('An event target must be provided');\n      }\n\n      if (!(eventTarget instanceof window.EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (!eventName) {\n        throw TypeError('An event name must be provided');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      if (!eventHandler) {\n        throw TypeError('An event handler must be provided');\n      }\n\n      if (typeof eventHandler != 'function') {\n        throw TypeError('The third argument must be a function');\n      }\n\n      useCapture = !!useCapture;\n      var eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n      var handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        handlersMap = new Map();\n        eventsMap.set(eventTarget, handlersMap);\n      }\n\n      var boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        boundHandlersMap = new Map();\n        handlersMap.set(eventName, boundHandlersMap);\n      }\n\n      var boundEventHandler = eventHandler.bind(this._context);\n\n      boundHandlersMap.set(eventHandler, boundEventHandler);\n\n      eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n    }\n  }, {\n    key: 'once',\n    value: function once(eventTarget, eventName, eventHandler, useCapture) {\n      var _this = this;\n\n      if (!eventTarget) {\n        throw TypeError('An event target must be provided');\n      }\n\n      if (!(eventTarget instanceof window.EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (!eventName) {\n        throw TypeError('An event name must be provided');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      if (!eventHandler) {\n        throw TypeError('An event handler must be provided');\n      }\n\n      if (typeof eventHandler != 'function') {\n        throw TypeError('The third argument must be a function');\n      }\n\n      useCapture = !!useCapture;\n      var eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n      var handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        handlersMap = new Map();\n        eventsMap.set(eventTarget, handlersMap);\n      }\n\n      var boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        boundHandlersMap = new Map();\n        handlersMap.set(eventName, boundHandlersMap);\n      }\n\n      var boundEventHandler = function boundEventHandler() {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this.off(eventTarget, eventName, eventHandler, useCapture);\n\n        return eventHandler.apply(_this._context, args);\n      };\n\n      boundHandlersMap.set(eventHandler, boundEventHandler);\n\n      eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n    }\n  }, {\n    key: 'off',\n    value: function off(eventTarget, eventName, eventHandler, useCapture) {\n      var eventTargetExists = eventTarget instanceof window.EventTarget;\n      var eventNameExists = typeof eventName == 'string';\n      var eventHandlerExists = typeof eventHandler == 'function';\n\n      if (eventTargetExists && eventNameExists && eventHandlerExists) {\n        useCapture = !!arguments[3];\n\n        var eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        var handlersMap = eventsMap.get(eventTarget);\n\n        if (!handlersMap) {\n          console.warn('Handlers map not found');\n          return;\n        }\n\n        var boundHandlersMap = handlersMap.get(eventName);\n\n        if (!boundHandlersMap) {\n          console.warn('Bound handlers map not found');\n          return;\n        }\n\n        var boundEventHandler = boundHandlersMap.get(eventHandler);\n\n        if (!boundEventHandler) {\n          console.warn('Bound event handler not found');\n          return;\n        }\n\n        boundHandlersMap.delete(eventHandler);\n\n        if (boundHandlersMap.size == 0) {\n          handlersMap.delete(eventName);\n        }\n\n        if (handlersMap.size == 0) {\n          eventsMap.delete(eventTarget);\n        }\n\n        eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n      } else if (eventTargetExists && eventNameExists) {\n        if (!(eventTarget instanceof window.EventTarget)) {\n          throw TypeError('The first argument must be an event target');\n        }\n\n        if (typeof eventName != 'string') {\n          throw TypeError('The second argument must be a string');\n        }\n\n        useCapture = !!arguments[2];\n\n        var _eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        var _handlersMap = _eventsMap.get(eventTarget);\n\n        if (!_handlersMap) {\n          console.warn('Handlers map not found');\n          return;\n        }\n\n        var _boundHandlersMap = _handlersMap.get(eventName);\n\n        if (!_boundHandlersMap) {\n          console.warn('Bound handlers map not found');\n          return;\n        }\n\n        _handlersMap.delete(eventName);\n\n        if (_handlersMap.size == 0) {\n          _eventsMap.delete(eventTarget);\n        }\n\n        _boundHandlersMap.forEach(function (boundEventHandler, eventHandler) {\n          _boundHandlersMap.delete(eventHandler);\n\n          eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n        });\n      } else if (eventTargetExists) {\n        if (!(eventTarget instanceof window.EventTarget)) {\n          throw TypeError('The first argument must be an event target');\n        }\n\n        useCapture = !!arguments[1];\n\n        var _eventsMap2 = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        var _handlersMap2 = _eventsMap2.get(eventTarget);\n\n        if (!_handlersMap2) {\n          console.warn('Handlers map not found');\n          return;\n        }\n\n        _eventsMap2.delete(eventTarget);\n\n        _handlersMap2.forEach(function (boundHandlersMap, eventName) {\n          _handlersMap2.delete(eventName);\n\n          boundHandlersMap.forEach(function (boundEventHandler, eventHandler) {\n            boundHandlersMap.delete(eventHandler);\n\n            eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n          });\n        });\n      } else {\n        useCapture = !!arguments[0];\n\n        var _eventsMap3 = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        _eventsMap3.forEach(function (handlersMap, eventTarget) {\n          _eventsMap3.delete(eventTarget);\n\n          handlersMap.forEach(function (boundHandlersMap, eventName) {\n            handlersMap.delete(eventName);\n\n            boundHandlersMap.forEach(function (boundEventHandler, eventHandler) {\n              boundHandlersMap.delete(eventHandler);\n\n              eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n            });\n          });\n        });\n      }\n    }\n  }, {\n    key: 'emit',\n    value: function emit() {\n      return _event_target2.default.emit.apply(_event_target2.default, arguments);\n    }\n  }]);\n\n  return EventsMap;\n}();\n\nexports.default = EventsMap;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(2);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// events_map.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7d211064729df7e0ec32","function CustomEvent(eventName, eventParams = {}) {\n  if (!eventName) {\n    throw TypeError('Event name must be provided');\n  }\n\n  if (typeof eventName != 'string') {\n    throw TypeError('Event name must be a string');\n  }\n\n  if (!(eventParams instanceof Object)) {\n    throw TypeError('Event parameters must be an object');\n  }\n\n  Object.assign({\n    bubbles: true,\n    cancelable: true,\n    detail: {}\n  }, eventParams);\n\n  const self = document.createEvent('CustomEvent');\n\n  self.initCustomEvent(\n    eventName,\n    eventParams.bubbles,\n    eventParams.cancelable,\n    eventParams.detail\n  );\n\n  return self;\n}\n\nCustomEvent.prototype = Object.create(window.Event.prototype);\nCustomEvent.prototype.constructor = CustomEvent;\n\nexport default CustomEvent;\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom_event.js","import CustomEvent from './custom_event';\n\nfunction EventTarget() {\n  const self = {\n    _listeners: {}\n  };\n\n  Object.setPrototypeOf(self, this.constructor.prototype);\n\n  return self;\n}\n\nEventTarget.prototype = Object.create(window.EventTarget.prototype);\nEventTarget.prototype.constructor = EventTarget;\n\nEventTarget.emit = function emit(eventTarget, eventName, eventParams) {\n  if (!eventTarget) {\n    throw TypeError('An event target must be provided');\n  }\n\n  if (!(eventTarget instanceof window.EventTarget)) {\n    throw TypeError('The first argument must be an event target');\n  }\n\n  if (!eventName) {\n    throw TypeError('An event name must be provided');\n  }\n\n  if (typeof eventName != 'string') {\n    throw TypeError('The second argument must be a string');\n  }\n\n  const event = new CustomEvent(eventName, eventParams);\n\n  eventTarget.dispatchEvent(event);\n};\n\nEventTarget.prototype.addEventListener = function addEventListener(type, callback) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  if (!(type in this._listeners)) {\n    this._listeners[type] = [];\n  }\n\n  this._listeners[type].push(callback);\n}\n\nEventTarget.prototype.removeEventListener = function removeEventListener(type, callback) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  if (!(type in this._listeners)) {\n    return;\n  }\n\n  const stack = this._listeners[type];\n\n  for (let i = 0, l = stack.length; i < l; i++) {\n    if (stack[i] === callback){\n      stack.splice(i, 1);\n      return;\n    }\n  }\n}\n\nEventTarget.prototype.dispatchEvent = function dispatchEvent(event) {\n  if (!event) {\n    throw TypeError('Event must be provided');\n  }\n\n  if (!(event instanceof Event)) {\n    throw TypeError('First argument must be an event');\n  }\n\n  if (!(event.type in this._listeners)) {\n    return true;\n  }\n\n  const stack = this._listeners[event.type];\n\n  Object.defineProperty(event, 'target', {\n    configurable: true,\n    get: () => this\n  });\n\n  for (let i = 0, l = stack.length; i < l; i++) {\n    stack[i].call(this, event);\n  }\n\n  return !event.defaultPrevented;\n}\n\nexport default EventTarget;\n\n\n\n// WEBPACK FOOTER //\n// ./src/event_target.js","export { default } from './events_map';\nexport { default as CustomEvent } from './custom_event';\nexport { default as EventTarget } from './event_target';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import CustomEvent from './custom_event';\nimport EventTarget from './event_target';\n\nclass EventsMap {\n  constructor(context = window) {\n    this._context = context;\n    this._bubbleEventsMap = new Map();\n    this._captureEventsMap = new Map();\n  }\n\n  on(eventTarget, eventName, eventHandler, useCapture) {\n    if (!eventTarget) {\n      throw TypeError('An event target must be provided');\n    }\n\n    if (!(eventTarget instanceof window.EventTarget)) {\n      throw TypeError('The first argument must be an event target');\n    }\n\n    if (!eventName) {\n      throw TypeError('An event name must be provided');\n    }\n\n    if (typeof eventName != 'string') {\n      throw TypeError('The second argument must be a string');\n    }\n\n    if (!eventHandler) {\n      throw TypeError('An event handler must be provided');\n    }\n\n    if (typeof eventHandler != 'function') {\n      throw TypeError('The third argument must be a function');\n    }\n\n    useCapture = !!useCapture;\n    const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n    let handlersMap = eventsMap.get(eventTarget);\n\n    if (!handlersMap) {\n      handlersMap = new Map();\n      eventsMap.set(eventTarget, handlersMap);\n    }\n\n    let boundHandlersMap = handlersMap.get(eventName);\n\n    if (!boundHandlersMap) {\n      boundHandlersMap = new Map();\n      handlersMap.set(eventName, boundHandlersMap);\n    }\n\n    const boundEventHandler = eventHandler.bind(this._context);\n\n    boundHandlersMap.set(eventHandler, boundEventHandler);\n\n    eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n  }\n\n  once(eventTarget, eventName, eventHandler, useCapture) {\n    if (!eventTarget) {\n      throw TypeError('An event target must be provided');\n    }\n\n    if (!(eventTarget instanceof window.EventTarget)) {\n      throw TypeError('The first argument must be an event target');\n    }\n\n    if (!eventName) {\n      throw TypeError('An event name must be provided');\n    }\n\n    if (typeof eventName != 'string') {\n      throw TypeError('The second argument must be a string');\n    }\n\n    if (!eventHandler) {\n      throw TypeError('An event handler must be provided');\n    }\n\n    if (typeof eventHandler != 'function') {\n      throw TypeError('The third argument must be a function');\n    }\n\n    useCapture = !!useCapture;\n    const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n    let handlersMap = eventsMap.get(eventTarget);\n\n    if (!handlersMap) {\n      handlersMap = new Map();\n      eventsMap.set(eventTarget, handlersMap);\n    }\n\n    let boundHandlersMap = handlersMap.get(eventName);\n\n    if (!boundHandlersMap) {\n      boundHandlersMap = new Map();\n      handlersMap.set(eventName, boundHandlersMap);\n    }\n\n    const boundEventHandler = (...args) => {\n      this.off(eventTarget, eventName, eventHandler, useCapture);\n\n      return eventHandler.apply(this._context, args);\n    };\n\n    boundHandlersMap.set(eventHandler, boundEventHandler);\n\n    eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n  }\n\n  off(eventTarget, eventName, eventHandler, useCapture) {\n    let eventTargetExists = eventTarget instanceof window.EventTarget;\n    let eventNameExists = typeof eventName == 'string';\n    let eventHandlerExists = typeof eventHandler == 'function';\n\n    if (eventTargetExists && eventNameExists && eventHandlerExists) {\n      useCapture = !!arguments[3];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      const handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        console.warn('Handlers map not found');\n        return;\n      }\n\n      const boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        console.warn('Bound handlers map not found');\n        return;\n      }\n\n      const boundEventHandler = boundHandlersMap.get(eventHandler);\n\n      if (!boundEventHandler) {\n        console.warn('Bound event handler not found');\n        return;\n      }\n\n      boundHandlersMap.delete(eventHandler);\n\n      if (boundHandlersMap.size == 0) {\n        handlersMap.delete(eventName);\n      }\n\n      if (handlersMap.size == 0) {\n        eventsMap.delete(eventTarget);\n      }\n\n      eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n    }\n    else if (eventTargetExists && eventNameExists) {\n      if (!(eventTarget instanceof window.EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      useCapture = !!arguments[2];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      const handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        console.warn('Handlers map not found');\n        return;\n      }\n\n      const boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        console.warn('Bound handlers map not found');\n        return;\n      }\n\n      handlersMap.delete(eventName);\n\n      if (handlersMap.size == 0) {\n        eventsMap.delete(eventTarget);\n      }\n\n      boundHandlersMap.forEach((boundEventHandler, eventHandler) => {\n        boundHandlersMap.delete(eventHandler);\n\n        eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n      });\n    }\n    else if (eventTargetExists) {\n      if (!(eventTarget instanceof window.EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      useCapture = !!arguments[1];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      const handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        console.warn('Handlers map not found');\n        return;\n      }\n\n      eventsMap.delete(eventTarget);\n\n      handlersMap.forEach((boundHandlersMap, eventName) => {\n        handlersMap.delete(eventName);\n\n        boundHandlersMap.forEach((boundEventHandler, eventHandler) => {\n          boundHandlersMap.delete(eventHandler);\n\n          eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n        });\n      });\n    }\n    else {\n      useCapture = !!arguments[0];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      eventsMap.forEach((handlersMap, eventTarget) => {\n        eventsMap.delete(eventTarget);\n\n        handlersMap.forEach((boundHandlersMap, eventName) => {\n          handlersMap.delete(eventName);\n\n          boundHandlersMap.forEach((boundEventHandler, eventHandler) => {\n            boundHandlersMap.delete(eventHandler);\n\n            eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n          });\n        });\n      });\n    }\n  }\n\n  emit(...args) {\n    return EventTarget.emit(...args);\n  }\n}\n\nexport default EventsMap;\n\n\n\n// WEBPACK FOOTER //\n// ./src/events_map.js"],"sourceRoot":""}