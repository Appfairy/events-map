{"version":3,"sources":["webpack:///events_map.min.js","webpack:///webpack/bootstrap 31315581bff51d7ed86b","webpack:///./src/custom_event.js","webpack:///./src/index.js","webpack:///./src/event_target.js","webpack:///./src/events_map.js","webpack:///./src/utils.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","CustomEvent","eventName","eventParams","arguments","length","undefined","TypeError","assign","bubbles","cancelable","detail","self","document","createEvent","initCustomEvent","create","window","Event","constructor","default","_interopRequireDefault","obj","_events_map","_custom_event","_event_target","EventTarget","_listeners","_pendingEvents","setPrototypeOf","this","_custom_event2","_utils","addEventListener","type","callback","push","removeEventListener","stack","splice","dispatchEvent","event","_this","defaultPrevented","silence","fn","_silenced","result","Function","queueEvent","onQueue","onDequeue","_this2","immediate","setImmediate","clearEvent","clearImmediate","_classCallCheck","instance","Constructor","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","EventsMap","context","_context","_bubbleEventsMap","Map","_captureEventsMap","eventTarget","eventHandler","useCapture","eventsMap","handlersMap","set","boundHandlersMap","boundEventHandler","bind","_len","args","Array","_key","off","apply","eventTargetExists","eventNameExists","eventHandlerExists","console","warn","delete","size","forEach","setTimeout","id","clearTimeout"],"mappings":"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","file":"events_map.min.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction CustomEvent(eventName) {\n  var eventParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!eventName) {\n    throw TypeError('Event name must be provided');\n  }\n\n  if (typeof eventName != 'string') {\n    throw TypeError('Event name must be a string');\n  }\n\n  if (!(eventParams instanceof Object)) {\n    throw TypeError('Event parameters must be an object');\n  }\n\n  Object.assign({\n    bubbles: true,\n    cancelable: true,\n    detail: {}\n  }, eventParams);\n\n  var self = document.createEvent('CustomEvent');\n\n  self.initCustomEvent(eventName, eventParams.bubbles, eventParams.cancelable, eventParams.detail);\n\n  return self;\n}\n\nCustomEvent.prototype = Object.create(window.Event.prototype);\nCustomEvent.prototype.constructor = CustomEvent;\n\nexports.default = CustomEvent;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _events_map = __webpack_require__(3);\n\nObject.defineProperty(exports, 'default', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_events_map).default;\n  }\n});\n\nvar _custom_event = __webpack_require__(0);\n\nObject.defineProperty(exports, 'CustomEvent', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_custom_event).default;\n  }\n});\n\nvar _event_target = __webpack_require__(2);\n\nObject.defineProperty(exports, 'EventTarget', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_event_target).default;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _custom_event = __webpack_require__(0);\n\nvar _custom_event2 = _interopRequireDefault(_custom_event);\n\nvar _utils = __webpack_require__(4);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction EventTarget() {\n  var self = {\n    _listeners: {},\n    _pendingEvents: {}\n  };\n\n  Object.setPrototypeOf(self, this.constructor.prototype);\n\n  return self;\n}\n\nEventTarget.prototype = Object.create(window.EventTarget.prototype);\nEventTarget.prototype.constructor = EventTarget;\n\nEventTarget.prototype.addEventListener = function addEventListener(type, callback) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  if (!(type in this._listeners)) {\n    this._listeners[type] = [];\n  }\n\n  this._listeners[type].push(callback);\n};\n\nEventTarget.prototype.removeEventListener = function removeEventListener(type, callback) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  if (!(type in this._listeners)) {\n    return;\n  }\n\n  var stack = this._listeners[type];\n\n  for (var i = 0, l = stack.length; i < l; i++) {\n    if (stack[i] === callback) {\n      stack.splice(i, 1);\n      return;\n    }\n  }\n};\n\nEventTarget.prototype.dispatchEvent = function dispatchEvent(event) {\n  var _this = this;\n\n  if (!event) {\n    throw TypeError('Event must be provided');\n  }\n\n  if (!(event instanceof Event)) {\n    throw TypeError('First argument must be an event');\n  }\n\n  if (!(event.type in this._listeners)) {\n    return true;\n  }\n\n  var stack = this._listeners[event.type];\n\n  Object.defineProperty(event, 'target', {\n    configurable: true,\n    get: function get() {\n      return _this;\n    }\n  });\n\n  for (var i = 0, l = stack.length; i < l; i++) {\n    stack[i].call(this, event);\n  }\n\n  return !event.defaultPrevented;\n};\n\nEventTarget.prototype.silence = function silence(fn) {\n  if (this._silenced) return;\n\n  this._silenced = true;\n  var dispatchEvent = this.dispatchEvent;\n  var result = void 0;\n\n  try {\n    this.dispatchEvent = Function();\n    result = fn.call(this);\n  } finally {\n    this._silenced = false;\n    this.dispatchEvent = dispatchEvent;\n  }\n\n  return result;\n};\n\nEventTarget.prototype.queueEvent = function queueEvent(eventName, onQueue, onDequeue) {\n  var _this2 = this;\n\n  if (this._pendingEvents[eventName] || this._silenced) return;\n\n  onQueue = onQueue || Function();\n  onDequeue = onDequeue || Function();\n  var detail = {};\n\n  onQueue(detail);\n\n  var immediate = (0, _utils.setImmediate)(function () {\n    delete _this2._pendingEvents[eventName];\n\n    onDequeue(detail);\n\n    _this2.dispatchEvent(new _custom_event2.default(eventName, { detail: detail }));\n  });\n\n  this._pendingEvents[eventName] = immediate;\n};\n\nEventTarget.prototype.clearEvent = function clearEvent(eventName) {\n  var immediate = this._pendingEvents[eventName];\n\n  if (!immediate) return;\n\n  (0, _utils.clearImmediate)(immediate);\n\n  delete this._pendingEvents[eventName];\n};\n\nexports.default = EventTarget;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _custom_event = __webpack_require__(0);\n\nvar _custom_event2 = _interopRequireDefault(_custom_event);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EventsMap = function () {\n  function EventsMap() {\n    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n\n    _classCallCheck(this, EventsMap);\n\n    this._context = context;\n    this._bubbleEventsMap = new Map();\n    this._captureEventsMap = new Map();\n  }\n\n  _createClass(EventsMap, [{\n    key: 'on',\n    value: function on(eventTarget, eventName, eventHandler, useCapture) {\n      if (typeof eventTarget == 'string') {\n        useCapture = eventHandler;\n        eventHandler = eventName;\n        eventName = eventTarget;\n        eventTarget = this._context;\n      }\n\n      if (!eventTarget) {\n        throw TypeError('An event target must be provided');\n      }\n\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (!eventName) {\n        throw TypeError('An event name must be provided');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      if (!eventHandler) {\n        throw TypeError('An event handler must be provided');\n      }\n\n      if (typeof eventHandler != 'function') {\n        throw TypeError('The third argument must be a function');\n      }\n\n      useCapture = !!useCapture;\n      var eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n      var handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        handlersMap = new Map();\n        eventsMap.set(eventTarget, handlersMap);\n      }\n\n      var boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        boundHandlersMap = new Map();\n        handlersMap.set(eventName, boundHandlersMap);\n      }\n\n      var boundEventHandler = eventHandler.bind(this._context);\n\n      boundHandlersMap.set(eventHandler, boundEventHandler);\n\n      eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n    }\n  }, {\n    key: 'once',\n    value: function once(eventTarget, eventName, eventHandler, useCapture) {\n      var _this = this;\n\n      if (typeof eventTarget == 'string') {\n        useCapture = eventHandler;\n        eventHandler = eventName;\n        eventName = eventTarget;\n        eventTarget = this._context;\n      }\n\n      if (!eventTarget) {\n        throw TypeError('An event target must be provided');\n      }\n\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (!eventName) {\n        throw TypeError('An event name must be provided');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      if (!eventHandler) {\n        throw TypeError('An event handler must be provided');\n      }\n\n      if (typeof eventHandler != 'function') {\n        throw TypeError('The third argument must be a function');\n      }\n\n      useCapture = !!useCapture;\n      var eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n      var handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        handlersMap = new Map();\n        eventsMap.set(eventTarget, handlersMap);\n      }\n\n      var boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        boundHandlersMap = new Map();\n        handlersMap.set(eventName, boundHandlersMap);\n      }\n\n      var boundEventHandler = function boundEventHandler() {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this.off(eventTarget, eventName, eventHandler, useCapture);\n\n        return eventHandler.apply(_this._context, args);\n      };\n\n      boundHandlersMap.set(eventHandler, boundEventHandler);\n\n      eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n    }\n  }, {\n    key: 'off',\n    value: function off(eventTarget, eventName, eventHandler, useCapture) {\n      if (typeof eventTarget == 'string') {\n        useCapture = eventHandler;\n        eventHandler = eventName;\n        eventName = eventTarget;\n        eventTarget = this._context;\n      }\n\n      var eventTargetExists = eventTarget instanceof EventTarget;\n      var eventNameExists = typeof eventName == 'string';\n      var eventHandlerExists = typeof eventHandler == 'function';\n\n      if (eventTargetExists && eventNameExists && eventHandlerExists) {\n        useCapture = !!arguments[3];\n\n        var eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        var handlersMap = eventsMap.get(eventTarget);\n\n        if (!handlersMap) {\n          console.warn('Handlers map not found');\n          return;\n        }\n\n        var boundHandlersMap = handlersMap.get(eventName);\n\n        if (!boundHandlersMap) {\n          console.warn('Bound handlers map not found');\n          return;\n        }\n\n        var boundEventHandler = boundHandlersMap.get(eventHandler);\n\n        if (!boundEventHandler) {\n          console.warn('Bound event handler not found');\n          return;\n        }\n\n        boundHandlersMap.delete(eventHandler);\n\n        if (boundHandlersMap.size == 0) {\n          handlersMap.delete(eventName);\n        }\n\n        if (handlersMap.size == 0) {\n          eventsMap.delete(eventTarget);\n        }\n\n        eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n      } else if (eventTargetExists && eventNameExists) {\n        if (!(eventTarget instanceof EventTarget)) {\n          throw TypeError('The first argument must be an event target');\n        }\n\n        if (typeof eventName != 'string') {\n          throw TypeError('The second argument must be a string');\n        }\n\n        useCapture = !!arguments[2];\n\n        var _eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        var _handlersMap = _eventsMap.get(eventTarget);\n\n        if (!_handlersMap) {\n          console.warn('Handlers map not found');\n          return;\n        }\n\n        var _boundHandlersMap = _handlersMap.get(eventName);\n\n        if (!_boundHandlersMap) {\n          console.warn('Bound handlers map not found');\n          return;\n        }\n\n        _handlersMap.delete(eventName);\n\n        if (_handlersMap.size == 0) {\n          _eventsMap.delete(eventTarget);\n        }\n\n        _boundHandlersMap.forEach(function (boundEventHandler, eventHandler) {\n          _boundHandlersMap.delete(eventHandler);\n\n          eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n        });\n      } else if (eventTargetExists) {\n        if (!(eventTarget instanceof EventTarget)) {\n          throw TypeError('The first argument must be an event target');\n        }\n\n        useCapture = !!arguments[1];\n\n        var _eventsMap2 = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        var _handlersMap2 = _eventsMap2.get(eventTarget);\n\n        if (!_handlersMap2) {\n          console.warn('Handlers map not found');\n          return;\n        }\n\n        _eventsMap2.delete(eventTarget);\n\n        _handlersMap2.forEach(function (boundHandlersMap, eventName) {\n          _handlersMap2.delete(eventName);\n\n          boundHandlersMap.forEach(function (boundEventHandler, eventHandler) {\n            boundHandlersMap.delete(eventHandler);\n\n            eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n          });\n        });\n      } else {\n        useCapture = !!arguments[0];\n\n        var _eventsMap3 = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        _eventsMap3.forEach(function (handlersMap, eventTarget) {\n          _eventsMap3.delete(eventTarget);\n\n          handlersMap.forEach(function (boundHandlersMap, eventName) {\n            handlersMap.delete(eventName);\n\n            boundHandlersMap.forEach(function (boundEventHandler, eventHandler) {\n              boundHandlersMap.delete(eventHandler);\n\n              eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n            });\n          });\n        });\n      }\n    }\n  }, {\n    key: 'emit',\n    value: function emit(eventTarget, eventName, eventParams) {\n      if (typeof eventTarget == 'string') {\n        eventParams = eventName;\n        eventName = eventTarget;\n        eventTarget = this._context;\n      }\n\n      if (!eventTarget) {\n        throw TypeError('An event target must be provided');\n      }\n\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (!eventName) {\n        throw TypeError('An event name must be provided');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      var event = new _custom_event2.default(eventName, eventParams);\n\n      eventTarget.dispatchEvent(event);\n    }\n  }]);\n\n  return EventsMap;\n}();\n\nexports.default = EventsMap;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\nfunction setImmediate(fn) {\n  return (window.setImmediate || setTimeout)(fn);\n}\n\nfunction clearImmediate(id) {\n  return (window.clearImmediate || clearTimeout)(id);\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// events_map.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 31315581bff51d7ed86b","function CustomEvent(eventName, eventParams = {}) {\n  if (!eventName) {\n    throw TypeError('Event name must be provided');\n  }\n\n  if (typeof eventName != 'string') {\n    throw TypeError('Event name must be a string');\n  }\n\n  if (!(eventParams instanceof Object)) {\n    throw TypeError('Event parameters must be an object');\n  }\n\n  Object.assign({\n    bubbles: true,\n    cancelable: true,\n    detail: {}\n  }, eventParams);\n\n  const self = document.createEvent('CustomEvent');\n\n  self.initCustomEvent(\n    eventName,\n    eventParams.bubbles,\n    eventParams.cancelable,\n    eventParams.detail\n  );\n\n  return self;\n}\n\nCustomEvent.prototype = Object.create(window.Event.prototype);\nCustomEvent.prototype.constructor = CustomEvent;\n\nexport default CustomEvent;\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom_event.js","export { default } from './events_map';\nexport { default as CustomEvent } from './custom_event';\nexport { default as EventTarget } from './event_target';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import CustomEvent from './custom_event';\nimport { clearImmediate, setImmediate } from './utils';\n\nfunction EventTarget() {\n  const self = {\n    _listeners: {},\n    _pendingEvents: {}\n  };\n\n  Object.setPrototypeOf(self, this.constructor.prototype);\n\n  return self;\n}\n\nEventTarget.prototype = Object.create(window.EventTarget.prototype);\nEventTarget.prototype.constructor = EventTarget;\n\nEventTarget.prototype.addEventListener = function addEventListener(type, callback) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  if (!(type in this._listeners)) {\n    this._listeners[type] = [];\n  }\n\n  this._listeners[type].push(callback);\n}\n\nEventTarget.prototype.removeEventListener = function removeEventListener(type, callback) {\n  if (!type) {\n    throw TypeError('Type must be provided');\n  }\n\n  if (typeof type != 'string') {\n    throw TypeError('Type must be a string');\n  }\n\n  if (!callback) {\n    throw TypeError('Callback must be provided');\n  }\n\n  if (typeof callback != 'function') {\n    throw TypeError('Callback must be a function');\n  }\n\n  if (!(type in this._listeners)) {\n    return;\n  }\n\n  const stack = this._listeners[type];\n\n  for (let i = 0, l = stack.length; i < l; i++) {\n    if (stack[i] === callback){\n      stack.splice(i, 1);\n      return;\n    }\n  }\n}\n\nEventTarget.prototype.dispatchEvent = function dispatchEvent(event) {\n  if (!event) {\n    throw TypeError('Event must be provided');\n  }\n\n  if (!(event instanceof Event)) {\n    throw TypeError('First argument must be an event');\n  }\n\n  if (!(event.type in this._listeners)) {\n    return true;\n  }\n\n  const stack = this._listeners[event.type];\n\n  Object.defineProperty(event, 'target', {\n    configurable: true,\n    get: () => this\n  });\n\n  for (let i = 0, l = stack.length; i < l; i++) {\n    stack[i].call(this, event);\n  }\n\n  return !event.defaultPrevented;\n}\n\nEventTarget.prototype.silence = function silence(fn) {\n  if (this._silenced) return;\n\n  this._silenced = true;\n  const dispatchEvent = this.dispatchEvent;\n  let result;\n\n  try {\n    this.dispatchEvent = Function();\n    result = fn.call(this);\n  }\n  finally {\n    this._silenced = false;\n    this.dispatchEvent = dispatchEvent;\n  }\n\n  return result;\n};\n\nEventTarget.prototype.queueEvent = function queueEvent(eventName, onQueue, onDequeue) {\n  if (this._pendingEvents[eventName] || this._silenced) return;\n\n  onQueue = onQueue || Function();\n  onDequeue = onDequeue || Function();\n  const detail = {};\n\n  onQueue(detail);\n\n  const immediate = setImmediate(() => {\n    delete this._pendingEvents[eventName];\n\n    onDequeue(detail);\n\n    this.dispatchEvent(new CustomEvent(eventName, { detail }));\n  });\n\n  this._pendingEvents[eventName] = immediate;\n};\n\nEventTarget.prototype.clearEvent = function clearEvent(eventName) {\n  const immediate = this._pendingEvents[eventName];\n\n  if (!immediate) return;\n\n  clearImmediate(immediate);\n\n  delete this._pendingEvents[eventName];\n};\n\nexport default EventTarget;\n\n\n\n// WEBPACK FOOTER //\n// ./src/event_target.js","import CustomEvent from './custom_event';\n\nclass EventsMap {\n  constructor(context = window) {\n    this._context = context;\n    this._bubbleEventsMap = new Map();\n    this._captureEventsMap = new Map();\n  }\n\n  on(eventTarget, eventName, eventHandler, useCapture) {\n    if (typeof eventTarget == 'string') {\n      useCapture = eventHandler;\n      eventHandler = eventName;\n      eventName = eventTarget;\n      eventTarget = this._context;\n    }\n\n    if (!eventTarget) {\n      throw TypeError('An event target must be provided');\n    }\n\n    if (!(eventTarget instanceof EventTarget)) {\n      throw TypeError('The first argument must be an event target');\n    }\n\n    if (!eventName) {\n      throw TypeError('An event name must be provided');\n    }\n\n    if (typeof eventName != 'string') {\n      throw TypeError('The second argument must be a string');\n    }\n\n    if (!eventHandler) {\n      throw TypeError('An event handler must be provided');\n    }\n\n    if (typeof eventHandler != 'function') {\n      throw TypeError('The third argument must be a function');\n    }\n\n    useCapture = !!useCapture;\n    const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n    let handlersMap = eventsMap.get(eventTarget);\n\n    if (!handlersMap) {\n      handlersMap = new Map();\n      eventsMap.set(eventTarget, handlersMap);\n    }\n\n    let boundHandlersMap = handlersMap.get(eventName);\n\n    if (!boundHandlersMap) {\n      boundHandlersMap = new Map();\n      handlersMap.set(eventName, boundHandlersMap);\n    }\n\n    const boundEventHandler = eventHandler.bind(this._context);\n\n    boundHandlersMap.set(eventHandler, boundEventHandler);\n\n    eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n  }\n\n  once(eventTarget, eventName, eventHandler, useCapture) {\n    if (typeof eventTarget == 'string') {\n      useCapture = eventHandler;\n      eventHandler = eventName;\n      eventName = eventTarget;\n      eventTarget = this._context;\n    }\n\n    if (!eventTarget) {\n      throw TypeError('An event target must be provided');\n    }\n\n    if (!(eventTarget instanceof EventTarget)) {\n      throw TypeError('The first argument must be an event target');\n    }\n\n    if (!eventName) {\n      throw TypeError('An event name must be provided');\n    }\n\n    if (typeof eventName != 'string') {\n      throw TypeError('The second argument must be a string');\n    }\n\n    if (!eventHandler) {\n      throw TypeError('An event handler must be provided');\n    }\n\n    if (typeof eventHandler != 'function') {\n      throw TypeError('The third argument must be a function');\n    }\n\n    useCapture = !!useCapture;\n    const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n    let handlersMap = eventsMap.get(eventTarget);\n\n    if (!handlersMap) {\n      handlersMap = new Map();\n      eventsMap.set(eventTarget, handlersMap);\n    }\n\n    let boundHandlersMap = handlersMap.get(eventName);\n\n    if (!boundHandlersMap) {\n      boundHandlersMap = new Map();\n      handlersMap.set(eventName, boundHandlersMap);\n    }\n\n    const boundEventHandler = (...args) => {\n      this.off(eventTarget, eventName, eventHandler, useCapture);\n\n      return eventHandler.apply(this._context, args);\n    };\n\n    boundHandlersMap.set(eventHandler, boundEventHandler);\n\n    eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n  }\n\n  off(eventTarget, eventName, eventHandler, useCapture) {\n    if (typeof eventTarget == 'string') {\n      useCapture = eventHandler;\n      eventHandler = eventName;\n      eventName = eventTarget;\n      eventTarget = this._context;\n    }\n\n    let eventTargetExists = eventTarget instanceof EventTarget;\n    let eventNameExists = typeof eventName == 'string';\n    let eventHandlerExists = typeof eventHandler == 'function';\n\n    if (eventTargetExists && eventNameExists && eventHandlerExists) {\n      useCapture = !!arguments[3];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      const handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        console.warn('Handlers map not found');\n        return;\n      }\n\n      const boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        console.warn('Bound handlers map not found');\n        return;\n      }\n\n      const boundEventHandler = boundHandlersMap.get(eventHandler);\n\n      if (!boundEventHandler) {\n        console.warn('Bound event handler not found');\n        return;\n      }\n\n      boundHandlersMap.delete(eventHandler);\n\n      if (boundHandlersMap.size == 0) {\n        handlersMap.delete(eventName);\n      }\n\n      if (handlersMap.size == 0) {\n        eventsMap.delete(eventTarget);\n      }\n\n      eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n    }\n    else if (eventTargetExists && eventNameExists) {\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      useCapture = !!arguments[2];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      const handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        console.warn('Handlers map not found');\n        return;\n      }\n\n      const boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        console.warn('Bound handlers map not found');\n        return;\n      }\n\n      handlersMap.delete(eventName);\n\n      if (handlersMap.size == 0) {\n        eventsMap.delete(eventTarget);\n      }\n\n      boundHandlersMap.forEach((boundEventHandler, eventHandler) => {\n        boundHandlersMap.delete(eventHandler);\n\n        eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n      });\n    }\n    else if (eventTargetExists) {\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      useCapture = !!arguments[1];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      const handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        console.warn('Handlers map not found');\n        return;\n      }\n\n      eventsMap.delete(eventTarget);\n\n      handlersMap.forEach((boundHandlersMap, eventName) => {\n        handlersMap.delete(eventName);\n\n        boundHandlersMap.forEach((boundEventHandler, eventHandler) => {\n          boundHandlersMap.delete(eventHandler);\n\n          eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n        });\n      });\n    }\n    else {\n      useCapture = !!arguments[0];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      eventsMap.forEach((handlersMap, eventTarget) => {\n        eventsMap.delete(eventTarget);\n\n        handlersMap.forEach((boundHandlersMap, eventName) => {\n          handlersMap.delete(eventName);\n\n          boundHandlersMap.forEach((boundEventHandler, eventHandler) => {\n            boundHandlersMap.delete(eventHandler);\n\n            eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n          });\n        });\n      });\n    }\n  }\n\n  emit(eventTarget, eventName, eventParams) {\n    if (typeof eventTarget == 'string') {\n      eventParams = eventName;\n      eventName = eventTarget;\n      eventTarget = this._context;\n    }\n\n    if (!eventTarget) {\n      throw TypeError('An event target must be provided');\n    }\n\n    if (!(eventTarget instanceof EventTarget)) {\n      throw TypeError('The first argument must be an event target');\n    }\n\n    if (!eventName) {\n      throw TypeError('An event name must be provided');\n    }\n\n    if (typeof eventName != 'string') {\n      throw TypeError('The second argument must be a string');\n    }\n\n    const event = new CustomEvent(eventName, eventParams);\n\n    eventTarget.dispatchEvent(event);\n  }\n}\n\nexport default EventsMap;\n\n\n\n// WEBPACK FOOTER //\n// ./src/events_map.js","export function setImmediate(fn) {\n  return (window.setImmediate || setTimeout)(fn);\n}\n\nexport function clearImmediate(id) {\n  return (window.clearImmediate || clearTimeout)(id);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js"],"sourceRoot":""}