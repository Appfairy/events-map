{"version":3,"sources":["webpack:///events_map.min.js","webpack:///webpack/bootstrap 8045e09c5cc0fba8047b","webpack:///./src/index.js","webpack:///./src/custom_event.js","webpack:///./src/events_map.js"],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_interopRequireDefault","obj","default","_events_map","CustomEvent","eventName","eventParams","arguments","length","undefined","TypeError","assign","bubbles","cancelable","detail","event","document","createEvent","initCustomEvent","create","window","Event","constructor","_classCallCheck","instance","Constructor","_createClass","defineProperties","target","props","descriptor","writable","key","protoProps","staticProps","_custom_event","_custom_event2","EventsMap","context","this","_context","_bubbleEventsMap","Map","_captureEventsMap","eventTarget","eventHandler","useCapture","EventTarget","eventsMap","handlersMap","set","boundHandlersMap","boundEventHandler","bind","addEventListener","_this","_len","args","Array","_key","off","apply","eventTargetExists","eventNameExists","eventHandlerExists","console","warn","delete","size","removeEventListener","forEach","dispatchEvent"],"mappings":"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","file":"events_map.min.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _events_map = __webpack_require__(2);\n\nObject.defineProperty(exports, 'default', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_events_map).default;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction CustomEvent(eventName) {\n  var eventParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!eventName) {\n    throw TypeError('Event name must be provided');\n  }\n\n  if (typeof eventName != 'string') {\n    throw TypeError('Event name must be a string');\n  }\n\n  if (!(eventParams instanceof Object)) {\n    throw TypeError('Event parameters must be an object');\n  }\n\n  Object.assign({\n    bubbles: true,\n    cancelable: true,\n    detail: {}\n  }, eventParams);\n\n  var event = document.createEvent('CustomEvent');\n\n  event.initCustomEvent(eventName, eventParams.bubbles, eventParams.cancelable, eventParams.detail);\n\n  return event;\n}\n\nCustomEvent.prototype = Object.create(window.Event.prototype);\nCustomEvent.prototype.constructor = CustomEvent;\n\nexports.default = CustomEvent;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _custom_event = __webpack_require__(1);\n\nvar _custom_event2 = _interopRequireDefault(_custom_event);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EventsMap = function () {\n  function EventsMap() {\n    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;\n\n    _classCallCheck(this, EventsMap);\n\n    this._context = context;\n    this._bubbleEventsMap = new Map();\n    this._captureEventsMap = new Map();\n  }\n\n  _createClass(EventsMap, [{\n    key: 'on',\n    value: function on(eventTarget, eventName, eventHandler, useCapture) {\n      if (!eventTarget) {\n        throw TypeError('An event target must be provided');\n      }\n\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (!eventName) {\n        throw TypeError('An event name must be provided');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      if (!eventHandler) {\n        throw TypeError('An event handler must be provided');\n      }\n\n      if (typeof eventHandler != 'function') {\n        throw TypeError('The third argument must be a function');\n      }\n\n      useCapture = !!useCapture;\n      var eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n      var handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        handlersMap = new Map();\n        eventsMap.set(eventTarget, handlersMap);\n      }\n\n      var boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        boundHandlersMap = new Map();\n        handlersMap.set(eventName, boundHandlersMap);\n      }\n\n      var boundEventHandler = eventHandler.bind(this._context);\n\n      boundHandlersMap.set(eventHandler, boundEventHandler);\n\n      eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n    }\n  }, {\n    key: 'once',\n    value: function once(eventTarget, eventName, eventHandler, useCapture) {\n      var _this = this;\n\n      if (!eventTarget) {\n        throw TypeError('An event target must be provided');\n      }\n\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (!eventName) {\n        throw TypeError('An event name must be provided');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      if (!eventHandler) {\n        throw TypeError('An event handler must be provided');\n      }\n\n      if (typeof eventHandler != 'function') {\n        throw TypeError('The third argument must be a function');\n      }\n\n      useCapture = !!useCapture;\n      var eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n      var handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        handlersMap = new Map();\n        eventsMap.set(eventTarget, handlersMap);\n      }\n\n      var boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        boundHandlersMap = new Map();\n        handlersMap.set(eventName, boundHandlersMap);\n      }\n\n      var boundEventHandler = function boundEventHandler() {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this.off(eventTarget, eventName, eventHandler, useCapture);\n\n        return eventHandler.apply(_this._context, args);\n      };\n\n      boundHandlersMap.set(eventHandler, boundEventHandler);\n\n      eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n    }\n  }, {\n    key: 'off',\n    value: function off(eventTarget, eventName, eventHandler, useCapture) {\n      var eventTargetExists = eventTarget instanceof EventTarget;\n      var eventNameExists = typeof eventName == 'string';\n      var eventHandlerExists = typeof eventHandler == 'function';\n\n      if (eventTargetExists && eventNameExists && eventHandlerExists) {\n        useCapture = !!arguments[3];\n\n        var eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        var handlersMap = eventsMap.get(eventTarget);\n\n        if (!handlersMap) {\n          console.warn('Handlers map not found');\n          return;\n        }\n\n        var boundHandlersMap = handlersMap.get(eventName);\n\n        if (!boundHandlersMap) {\n          console.warn('Bound handlers map not found');\n          return;\n        }\n\n        var boundEventHandler = boundHandlersMap.get(eventHandler);\n\n        if (!boundEventHandler) {\n          console.warn('Bound event handler not found');\n          return;\n        }\n\n        boundHandlersMap.delete(eventHandler);\n\n        if (boundHandlersMap.size == 0) {\n          handlersMap.delete(eventName);\n        }\n\n        if (handlersMap.size == 0) {\n          eventsMap.delete(eventTarget);\n        }\n\n        eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n      } else if (eventTargetExists && eventNameExists) {\n        if (!(eventTarget instanceof EventTarget)) {\n          throw TypeError('The first argument must be an event target');\n        }\n\n        if (typeof eventName != 'string') {\n          throw TypeError('The second argument must be a string');\n        }\n\n        useCapture = !!arguments[2];\n\n        var _eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        var _handlersMap = _eventsMap.get(eventTarget);\n\n        if (!_handlersMap) {\n          console.warn('Handlers map not found');\n          return;\n        }\n\n        var _boundHandlersMap = _handlersMap.get(eventName);\n\n        if (!_boundHandlersMap) {\n          console.warn('Bound handlers map not found');\n          return;\n        }\n\n        _handlersMap.delete(eventName);\n\n        if (_handlersMap.size == 0) {\n          _eventsMap.delete(eventTarget);\n        }\n\n        _boundHandlersMap.forEach(function (boundEventHandler, eventHandler) {\n          _boundHandlersMap.delete(eventHandler);\n\n          eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n        });\n      } else if (eventTargetExists) {\n        if (!(eventTarget instanceof EventTarget)) {\n          throw TypeError('The first argument must be an event target');\n        }\n\n        useCapture = !!arguments[1];\n\n        var _eventsMap2 = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        var _handlersMap2 = _eventsMap2.get(eventTarget);\n\n        if (!_handlersMap2) {\n          console.warn('Handlers map not found');\n          return;\n        }\n\n        _eventsMap2.delete(eventTarget);\n\n        _handlersMap2.forEach(function (boundHandlersMap, eventName) {\n          _handlersMap2.delete(eventName);\n\n          boundHandlersMap.forEach(function (boundEventHandler, eventHandler) {\n            boundHandlersMap.delete(eventHandler);\n\n            eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n          });\n        });\n      } else {\n        useCapture = !!arguments[0];\n\n        var _eventsMap3 = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n        _eventsMap3.forEach(function (handlersMap, eventTarget) {\n          _eventsMap3.delete(eventTarget);\n\n          handlersMap.forEach(function (boundHandlersMap, eventName) {\n            handlersMap.delete(eventName);\n\n            boundHandlersMap.forEach(function (boundEventHandler, eventHandler) {\n              boundHandlersMap.delete(eventHandler);\n\n              eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n            });\n          });\n        });\n      }\n    }\n  }, {\n    key: 'emit',\n    value: function emit(eventTarget, eventName, eventParams) {\n      if (!eventTarget) {\n        throw TypeError('An event target must be provided');\n      }\n\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (!eventName) {\n        throw TypeError('An event name must be provided');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      var event = new _custom_event2.default(eventName, eventParams);\n\n      eventTarget.dispatchEvent(event);\n    }\n  }]);\n\n  return EventsMap;\n}();\n\nexports.default = EventsMap;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(0);\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// events_map.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8045e09c5cc0fba8047b","export { default } from './events_map';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","function CustomEvent(eventName, eventParams = {}) {\n  if (!eventName) {\n    throw TypeError('Event name must be provided');\n  }\n\n  if (typeof eventName != 'string') {\n    throw TypeError('Event name must be a string');\n  }\n\n  if (!(eventParams instanceof Object)) {\n    throw TypeError('Event parameters must be an object');\n  }\n\n  Object.assign({\n    bubbles: true,\n    cancelable: true,\n    detail: {}\n  }, eventParams);\n\n  const event = document.createEvent('CustomEvent');\n\n  event.initCustomEvent(\n    eventName,\n    eventParams.bubbles,\n    eventParams.cancelable,\n    eventParams.detail\n  );\n\n  return event;\n}\n\nCustomEvent.prototype = Object.create(window.Event.prototype);\nCustomEvent.prototype.constructor = CustomEvent;\n\nexport default CustomEvent;\n\n\n\n// WEBPACK FOOTER //\n// ./src/custom_event.js","import CustomEvent from './custom_event';\n\nclass EventsMap {\n  constructor(context = window) {\n    this._context = context;\n    this._bubbleEventsMap = new Map();\n    this._captureEventsMap = new Map();\n  }\n\n  on(eventTarget, eventName, eventHandler, useCapture) {\n    if (!eventTarget) {\n      throw TypeError('An event target must be provided');\n    }\n\n    if (!(eventTarget instanceof EventTarget)) {\n      throw TypeError('The first argument must be an event target');\n    }\n\n    if (!eventName) {\n      throw TypeError('An event name must be provided');\n    }\n\n    if (typeof eventName != 'string') {\n      throw TypeError('The second argument must be a string');\n    }\n\n    if (!eventHandler) {\n      throw TypeError('An event handler must be provided');\n    }\n\n    if (typeof eventHandler != 'function') {\n      throw TypeError('The third argument must be a function');\n    }\n\n    useCapture = !!useCapture;\n    const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n    let handlersMap = eventsMap.get(eventTarget);\n\n    if (!handlersMap) {\n      handlersMap = new Map();\n      eventsMap.set(eventTarget, handlersMap);\n    }\n\n    let boundHandlersMap = handlersMap.get(eventName);\n\n    if (!boundHandlersMap) {\n      boundHandlersMap = new Map();\n      handlersMap.set(eventName, boundHandlersMap);\n    }\n\n    const boundEventHandler = eventHandler.bind(this._context);\n\n    boundHandlersMap.set(eventHandler, boundEventHandler);\n\n    eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n  }\n\n  once(eventTarget, eventName, eventHandler, useCapture) {\n    if (!eventTarget) {\n      throw TypeError('An event target must be provided');\n    }\n\n    if (!(eventTarget instanceof EventTarget)) {\n      throw TypeError('The first argument must be an event target');\n    }\n\n    if (!eventName) {\n      throw TypeError('An event name must be provided');\n    }\n\n    if (typeof eventName != 'string') {\n      throw TypeError('The second argument must be a string');\n    }\n\n    if (!eventHandler) {\n      throw TypeError('An event handler must be provided');\n    }\n\n    if (typeof eventHandler != 'function') {\n      throw TypeError('The third argument must be a function');\n    }\n\n    useCapture = !!useCapture;\n    const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n    let handlersMap = eventsMap.get(eventTarget);\n\n    if (!handlersMap) {\n      handlersMap = new Map();\n      eventsMap.set(eventTarget, handlersMap);\n    }\n\n    let boundHandlersMap = handlersMap.get(eventName);\n\n    if (!boundHandlersMap) {\n      boundHandlersMap = new Map();\n      handlersMap.set(eventName, boundHandlersMap);\n    }\n\n    const boundEventHandler = (...args) => {\n      this.off(eventTarget, eventName, eventHandler, useCapture);\n\n      return eventHandler.apply(this._context, args);\n    };\n\n    boundHandlersMap.set(eventHandler, boundEventHandler);\n\n    eventTarget.addEventListener(eventName, boundEventHandler, useCapture);\n  }\n\n  off(eventTarget, eventName, eventHandler, useCapture) {\n    let eventTargetExists = eventTarget instanceof EventTarget;\n    let eventNameExists = typeof eventName == 'string';\n    let eventHandlerExists = typeof eventHandler == 'function';\n\n    if (eventTargetExists && eventNameExists && eventHandlerExists) {\n      useCapture = !!arguments[3];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      const handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        console.warn('Handlers map not found');\n        return;\n      }\n\n      const boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        console.warn('Bound handlers map not found');\n        return;\n      }\n\n      const boundEventHandler = boundHandlersMap.get(eventHandler);\n\n      if (!boundEventHandler) {\n        console.warn('Bound event handler not found');\n        return;\n      }\n\n      boundHandlersMap.delete(eventHandler);\n\n      if (boundHandlersMap.size == 0) {\n        handlersMap.delete(eventName);\n      }\n\n      if (handlersMap.size == 0) {\n        eventsMap.delete(eventTarget);\n      }\n\n      eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n    }\n    else if (eventTargetExists && eventNameExists) {\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      if (typeof eventName != 'string') {\n        throw TypeError('The second argument must be a string');\n      }\n\n      useCapture = !!arguments[2];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      const handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        console.warn('Handlers map not found');\n        return;\n      }\n\n      const boundHandlersMap = handlersMap.get(eventName);\n\n      if (!boundHandlersMap) {\n        console.warn('Bound handlers map not found');\n        return;\n      }\n\n      handlersMap.delete(eventName);\n\n      if (handlersMap.size == 0) {\n        eventsMap.delete(eventTarget);\n      }\n\n      boundHandlersMap.forEach((boundEventHandler, eventHandler) => {\n        boundHandlersMap.delete(eventHandler);\n\n        eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n      });\n    }\n    else if (eventTargetExists) {\n      if (!(eventTarget instanceof EventTarget)) {\n        throw TypeError('The first argument must be an event target');\n      }\n\n      useCapture = !!arguments[1];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      const handlersMap = eventsMap.get(eventTarget);\n\n      if (!handlersMap) {\n        console.warn('Handlers map not found');\n        return;\n      }\n\n      eventsMap.delete(eventTarget);\n\n      handlersMap.forEach((boundHandlersMap, eventName) => {\n        handlersMap.delete(eventName);\n\n        boundHandlersMap.forEach((boundEventHandler, eventHandler) => {\n          boundHandlersMap.delete(eventHandler);\n\n          eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n        });\n      });\n    }\n    else {\n      useCapture = !!arguments[0];\n\n      const eventsMap = useCapture ? this._captureEventsMap : this._bubbleEventsMap;\n\n      eventsMap.forEach((handlersMap, eventTarget) => {\n        eventsMap.delete(eventTarget);\n\n        handlersMap.forEach((boundHandlersMap, eventName) => {\n          handlersMap.delete(eventName);\n\n          boundHandlersMap.forEach((boundEventHandler, eventHandler) => {\n            boundHandlersMap.delete(eventHandler);\n\n            eventTarget.removeEventListener(eventName, boundEventHandler, useCapture);\n          });\n        });\n      });\n    }\n  }\n\n  emit(eventTarget, eventName, eventParams) {\n    if (!eventTarget) {\n      throw TypeError('An event target must be provided');\n    }\n\n    if (!(eventTarget instanceof EventTarget)) {\n      throw TypeError('The first argument must be an event target');\n    }\n\n    if (!eventName) {\n      throw TypeError('An event name must be provided');\n    }\n\n    if (typeof eventName != 'string') {\n      throw TypeError('The second argument must be a string');\n    }\n\n    const event = new CustomEvent(eventName, eventParams);\n\n    eventTarget.dispatchEvent(event);\n  }\n}\n\nexport default EventsMap;\n\n\n\n// WEBPACK FOOTER //\n// ./src/events_map.js"],"sourceRoot":""}